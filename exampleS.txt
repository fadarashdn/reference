{
  "files": {
    "Dashboard.tsx": "import { Services } from '@/services/url'; import { useGet } from '@brdp/engine'; import { WidgetGenerator } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; const DashboardPage: React.FC = () => { const messages = getFormatMessage(); const { data: currentDateTime, isLoading: isLoadingCurrentDateTime } = useGet<string>(['get-current-date-time'], Services.Common.GET_CURRENT_DATE_TIME()); return <WidgetGenerator widgets={[{ type: 'date', title: `${messages(generalMessages.today)}:`, isLoading: isLoadingCurrentDateTime, hasCenterBody: true, data: currentDateTime?.resultData }]} />; }; export default DashboardPage;",
    "sima-messages.ts": "import { defineMessages } from '@brdp/utils'; const rawMessages = { securitiesManagement: { id: 'sima.securitiesManagement', defaultMessage: 'مدیریت اوراق' }, securitiesCode: { id: 'sima.securitiesCode', defaultMessage: 'کد شباب' }, securitiesName: { id: 'sima.securitiesName', defaultMessage: 'عنوان اوراق' }, amountFrom: { id: 'sima.amountFrom', defaultMessage: 'مبلغ از' }, /* ...truncated for brevity, include all messages... */ newSheba: { id: 'sima.newSheba', defaultMessage: 'شبا جدید' } } as const; type RawMessagesDictionary = typeof rawMessages; const simaMessages = defineMessages(rawMessages); export default simaMessages as RawMessagesDictionary;",
    "transfer-contract-table.tsx": "import React from 'react'; import { BusinessElementFieldsProps } from '@brdp/ui/form/form-field'; import { GenerativeTable, useTablePagination } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import simaMessages from '@/pages/dashboard/sima-messages'; export type TransferContractTableType = { interestReceptionDate: string; interestMatureAmount: string; interestPayAbleAmount: string; }; const TransferContractTable: React.FC<BusinessElementFieldsProps<{ tableData: TransferContractTableType[]; currencyName: string; }>> = ({ ...props }) => { const messages = getFormatMessage(); const { tableConfig, tableFromIndex } = useTablePagination(); const tableData = props.options?.extraProps?.tableData; const currencyName = props.options?.extraProps?.currencyName; const convertedTableData = tableData?.map((item, index) => ({ ...item, id: index + 1 })) || []; return ( <GenerativeTable<TransferContractTableType> rowKey='id' fromIndex={tableFromIndex} data={convertedTableData || []} pagination={tableConfig(tableData?.length || 0)} size='small' columns={[{ key: 'interestReceptionDate', dataIndex: 'interestReceptionDate', title: messages(simaMessages.interestReceiptPeriods) }, { key: 'interestMatureAmount', dataIndex: 'interestMatureAmount', title: messages(simaMessages.dueInterestAmount, { title: currencyName ? `(${currencyName})` : `(${messages(generalMessages.rial)})` }) }, { key: 'interestPayAbleAmount', dataIndex: 'interestPayAbleAmount', title: messages(simaMessages.payableInterestAmount, { title: currencyName ? `(${currencyName})` : `(${messages(generalMessages.rial)})` }) }]} /> ); }; export default TransferContractTable;",
    "Paths.ts": "const Paths = { Root: '/dashboard/sima', Dashboard: '/dashboard/sima', SecuritiesManagement: '/dashboard/sima/securities-management', ContractsManagement: '/dashboard/sima/contracts-management', AccountManagement: '/dashboard/sima/account-management', CustomersManagement: '/dashboard/sima/customers-management' } as const; export type PathKeys = typeof Paths[keyof typeof Paths]; export default Paths;",
    "routes.tsx": "import AccountManagement from '@/pages/dashboard/account-management'; import ContractsManagement from '@/pages/dashboard/contracts-management'; import CustomersManagement from '@/pages/dashboard/customers-management'; import DashboardPage from '@/pages/dashboard/Dashboard'; import Sima from '@/pages/dashboard/securities-management'; import AppConfigProvider from '@/provider/AppConfigProvider'; import Paths from '@/routes/Paths'; import { ErrorPage, Typography } from '@brdp/ui'; import { createBrowserRouter, Navigate } from 'react-router'; const routes = createBrowserRouter([{ path: Paths.Dashboard, Component: AppConfigProvider, errorElement: <ErrorPage />, children: [{ index: true, element: <DashboardPage /> }, { path: Paths.SecuritiesManagement, element: <Sima /> }, { path: Paths.CustomersManagement, element: <CustomersManagement /> }, { path: Paths.ContractsManagement, element: <ContractsManagement /> }, { path: Paths.AccountManagement, element: <AccountManagement /> }, { path: '*', element: <Typography text='زیرسامانه مورد نظر پیدا نشد!' /> }] }, { path: '*', element: <Navigate to={Paths.Dashboard} replace /> }]); export default routes;",
    "store.ts": "import { configureStore } from '@reduxjs/toolkit'; import { modalReducer } from '@brdp/engine'; const store = configureStore({ reducer: { modalReducer }, middleware: (getDefaultMiddleware) => getDefaultMiddleware({ serializableCheck: false }), devTools: process.env.NODE_ENV !== 'production' }); export type RootState = ReturnType<typeof store.getState>; export type AppDispatch = typeof store.dispatch; export default store;",
    "storeHooks.ts": "import { useDispatch, useSelector, useStore } from 'react-redux'; import type { RootState, AppDispatch } from '@/store/store'; export const useAppDispatch = useDispatch.withTypes<AppDispatch>(); export const useAppSelector = useSelector.withTypes<RootState>(); export const useAppStore = useStore.withTypes<RootState>();",
    "AppConfigProvider.tsx": "import Paths from '@/routes/Paths'; import useAppModal from '@/utils/hooks/useAppModal'; import { useCurrentUserData, useGetVersion } from '@brdp/engine'; import { ErrorBoundary, IconsList, ThemedLayout, type UiConfig } from '@brdp/ui'; import { type ConfigProviderProps, Spin, type ThemeConfig } from 'antd'; import { Outlet, useMatch } from 'react-router'; import logo from '../../public/banks/pasargad/logo-gray.svg'; const theme: ThemeConfig = { token: { colorPrimary: '#924E6F', fontFamily: 'IRANSansX', colorSplit: '#DFDFDF', colorTextQuaternary: '#000', colorTextPlaceholder: 'rgba(0,0,0,0.25)' }, components: { Card: { headerBg: '#f9fafd' }, Collapse: { headerPadding: 0 }, Menu: { darkItemSelectedBg: 'rgba(0, 0, 0, 0.5)', darkSubMenuItemBg: 'rgba(0, 0, 0, 0.15)', iconSize: 20, darkPopupBg: '#222a32', itemHeight: 48, itemMarginBlock: 0, itemMarginInline: 8 }, Layout: { siderBg: 'linear-gradient(180deg, #2e3743 0%, #192227 100%)' } }, cssVar: { prefix: 'ant' }, hashed: false }; const themeConfig: ConfigProviderProps = { theme }; const AppConfigProvider: React.FC<React.PropsWithChildren> = () => { const { Component: ModalComponent } = useAppModal(); const { data, isLoading, menuItems, currentMenuItems } = useCurrentUserData(); const { lastVersion } = useGetVersion('sima'); const isDashboard = useMatch('/dashboard/sima'); const layoutConfig: UiConfig = { rootPath: Paths.Root, title: 'سامانه یکپارچه مدیریت اوراق بهادار (سیما)', logo: isDashboard ? logo : null, appIcon: 'SimaHeaderIcon', loading: isLoading, themeConfig, profile: { userRole: data?.resultData.userInformationService.roleTitle || '', label: data?.resultData.userInformationService.fullName || '' }, profileMenuItems: [{ key: '/auth/signout', label: 'خروج از نرم افزار', icon: <IconsList.LogoutIcon /> }], appsMenu: menuItems as UiConfig['appsMenu'], menuItems: currentMenuItems, version: { number: lastVersion?.number ?? '', features: lastVersion?.features ?? [] } }; return ( <ThemedLayout uiConfig={layoutConfig}> <title>{layoutConfig.title}</title> <Spin fullscreen size='large' spinning={isLoading} /> <ErrorBoundary><Outlet /></ErrorBoundary> <ModalComponent /> </ThemedLayout> ); }; export default AppConfigProvider;",
    "url.ts": "import { objectToQueryString } from '@brdp/utils'; import { URLDefinition } from '@brdp/engine'; import { type GetAmountPropType } from '@/pages/dashboard/securities-management/components/modal-forms/sale-form/amount-confirmation'; import { type GetAccountPropType } from '@/pages/dashboard/account-management'; import { type TransactionProfitManagementModalPropsType } from '@/pages/dashboard/account-management/components/modal-forms/transaction-profit-management-modal'; const General = { BASE: 'api/', AUTH_LOGIN: () => `api/login` } as const satisfies URLDefinition; const Common = { GET_CURRENT_DATE_TIME: () => `/ExternalServices/Common/GetCurrentDateTime` } as const satisfies URLDefinition; const Search = { ACCOUNTS: 'api/v1/accounts', SEARCH_BY_CODE: (code: string) => `api/v1/accounts?code=${code}`, SEARCH_BY_QUERY: (params: Record<string, unknown>) => `api/v1/accounts?${objectToQueryString(params)}` } as const satisfies URLDefinition; const SubSystem = { GET_SUBSYSTEMS: (filters: { start: number; size: number; order: 'CREATED'; desc: boolean }) => `/api/dms/admins/subsystems?${objectToQueryString(filters)}`, GET_SUBSYSTEM: (username: string) => `/api/dms/admins/subsystems/${username}`, POST_SUBSYSTEMS: (params: { username: string; title: string }) => `/api/dms/admins/subsystems?${objectToQueryString(params)}`, EDIT_SUBSYSTEM: ({ username, ...rest }: { username: string; newUsername?: string; title?: string; isActive?: boolean }) => `/api/dms/admins/subsystems/${username}?${objectToQueryString(rest)}` } as const satisfies URLDefinition; const Sima = { GET_SECURITIES: (filters: { pageIndex: number; pageSize: number; orderBy: 'id'; transferable: boolean | undefined; redeemable: boolean | undefined; resalableByPublisher: boolean | undefined; resalableByAgent: boolean | undefined; securitiesCode: string | undefined; securitiesName: string | undefined; statusCategoryCode: string | undefined; amountFrom: number | null | undefined; amountTo: number | null | undefined; sellingStartDateFrom: string | undefined; sellingStartDateTo: string | undefined; sellingEndDateFrom: string | undefined; sellingEndDateTo: string | undefined; statusSecuritiesCodeList: string[] | undefined; isSpecial: boolean | null | undefined }) => `/api/sima/securities?${objectToQueryString(filters)}`, GET_SECURITY_DETAIL: (code: string) => `/api/sima/securities/${code}`, GET_CATEGORIES: (categoryCode: string) => `/api/sima/categories/${categoryCode}`, POST_ALLOCATE_SECURITIES: () => `/api/sima/securities/allocate`, UPDATE_IBAN: (code: string) => `/api/sima/securities/${code}/update-iban`, GET_SECURITIES_REQUESTS: (filters: { pageIndex: number; pageSize: number; securitiesCode: string }) => `/api/sima/securities/requests?${objectToQueryString(filters)}`, GET_DEPOSIT_TOPIC_INFO: (securitiesCode: string) => `/api/sima/securities/${securitiesCode}/deposit-topic-info`, GET_TOPIC_INFO: () => `/api/sima/topic-info`, POST_INTEREST_INFO_TOPIC: () => `/api/sima/securities/interest-info-topic`, POST_INTEREST_INFO_DEPOSIT: () => `/api/sima/securities/interest-info-deposit`, GET_SALE_SECURITIES_DIALOG: (code: string) => `/api/sima/securities/${code}/sale-dialog`, GET_VALIDATE_SALE_SECURITIES: (data: GetAmountPropType) => `/api/sima/securities/validate-sale?${objectToQueryString(data)}`, POST_SALE_SECURITIES_COMPLETE: () => `/api/sima/securities/sale-complete`, GET_AMOUNT_CONFIRMATION: (data: GetAmountPropType) => `/api/sima/securities/amount-confirmation?${objectToQueryString(data)}`, GET_CUSTOMERS: (filters: { pageIndex: number; pageSize: number; identifierTypeCode: string | undefined; identifier: string | undefined; statusCode: string | undefined; customerNumber: string | undefined }) => `/api/sima/customers?${objectToQueryString(filters)}`, GET_CUSTOMER_DETAIL: (filters: { identifier: string; identifierTypeCode: string }) => `/api/sima/customers/detail?${objectToQueryString(filters)}`, GET_CUSTOMER_BLOCK_STATUS: (filters: { identifier: string; identifierTypeCode: string }) => `/api/sima/customers/block-status?${objectToQueryString(filters)}`, POST_BLOCK_CUSTOMER: () => `/api/sima/customers/block`, POST_UNBLOCK_CUSTOMER: () => `/api/sima/customers/unblock`, GET_CUSTOMER_REQUESTS: (filters: { pageIndex: number; pageSize: number; customerNumber: number }) => `/api/sima/customers/requests?${objectToQueryString(filters)}`, GET_CONTRACTS: (filters: { pageIndex: number; pageSize: number; orderBy: 'id'; customerNumber: string | undefined; simaTransactionId: string | undefined }) => `/api/sima/contracts?${objectToQueryString(filters)}`, GET_CONTRACT_DETAIL: (contractId: number) => `/api/sima/contracts/${contractId}`, GET_COTRACT_VIEW: (contractId: number) => `/api/sima/contracts/${contractId}/view`, GET_CONTRACT_TRANSFER_VALIDATION: (filters: { customerNumber: number; outDateInterest: number; shababCode: string; countOfPapers: number; count: number; parentContractId: number; buyerCustomerNumber: string; buyerDepositNumber: string }) => `/api/sima/contracts/transfer-validation?${objectToQueryString(filters)}`, POST_TRANSFER_PREVIEW: () => `/api/sima/contracts/transfer-preview`, POST_REDEEM_SECURITIES: () => `/api/sima/contracts/redeem`, UPDATE_IBAN_CONTRACT: (contractId: number) => `/api/sima/contracts/${contractId}/update-iban`, POST_CANCEL_CONTRACT: () => `/api/sima/contracts/cancel`, GET_CONTRACT_REQUESTS: (contractId: number) => `/api/sima/contracts/${contractId}/requests`, GET_PERFORATION_CONTRACT: (contractId: number) => `/api/sima/contracts/${contractId}/perforation`, GET_COUNT_OF_CONTRACT: (filters: { customerNumber: number; contractId: number }) => `/api/sima/contracts/${contractId}/count?${objectToQueryString(filters)}`, GET_REDEMPTION_INTEREST: (filters: { customerNumber: number; parentContractId: number; redemptionCount: number; redemptionTradingSourceTypeCode: string; availableCount: number }) => `/api/sima/contracts/${filters.parentContractId}/redemption-interest?${objectToQueryString(filters)}`, GET_ACCOUNTS: (filters: GetAccountPropType) => `/api/sima/accounts?${objectToQueryString(filters)}`, GET_ACCOUNT_DETAIL: (accountNumber: string) => `/api/sima/accounts/${accountNumber}`, GET_ACCOUNT_REQUESTS: (filters: { pageIndex: number; pageSize: number; accountNumber: string }) => `/api/sima/accounts/requests?${objectToQueryString(filters)}`, POST_BLOCK_ACCOUNT: () => `/api/sima/accounts/block`, POST_UNBLOCK_ACCOUNT: () => `/api/sima/accounts/unblock`, GET_TRANSACTIONS: (filters: { pageIndex: number; pageSize: number; accountNumber: string; fromDate: string | undefined; toDate: string | undefined }) => `/api/sima/transactions?${objectToQueryString(filters)}`, GET_TRANSACTION_PROFIT: (filters: TransactionProfitManagementModalPropsType) => `/api/sima/transactions/profit?${objectToQueryString(filters)}` } as const satisfies URLDefinition; const Properties = { GET_PROPERTIES: (filters: { pageIndex: number; pageSize: number; orderBy: 'id'; propertyCode: string | undefined; propertyName: string | undefined; statusCategoryCode: string | undefined }) => `/api/properties?${objectToQueryString(filters)}`, GET_PROPERTY_DETAIL: (code: string) => `/api/properties/${code}`, GET_PROPERTY_CATEGORIES: (categoryCode: string) => `/api/properties/categories/${categoryCode}`, POST_PROPERTY: () => `/api/properties`, UPDATE_PROPERTY: (code: string) => `/api/properties/${code}`, DELETE_PROPERTY: (code: string) => `/api/properties/${code}` } as const satisfies URLDefinition; const Groups = { GET_GROUPS: (filters: { pageIndex: number; pageSize: number; orderBy: 'id'; groupCode: string | undefined; groupName: string | undefined; statusCategoryCode: string | undefined }) => `/api/groups?${objectToQueryString(filters)}`, GET_GROUP_DETAIL: (code: string) => `/api/groups/${code}`, GET_GROUP_CATEGORIES: (categoryCode: string) => `/api/groups/categories/${categoryCode}`, POST_GROUP: () => `/api/groups`, UPDATE_GROUP: (code: string) => `/api/groups/${code}`, DELETE_GROUP: (code: string) => `/api/groups/${code}` } as const satisfies URLDefinition; const DocumentTypes = { GET_DOCUMENT_TYPES: (params?) => `/api/dms/types/search?${objectToQueryString(params)}`, GET_ALL: () => `/api/dms/types`, GET_CRUMB: (code: number) => `/api/dms/types/${code}/breadcrumb`, GET_DOCTYPE: (code: number) => `/api/dms/types/${code}`, GET_CONDITIONS: () => `/api/dms/types/conditions`, POST_DOCTYPES: (params) => `/api/dms/types?${objectToQueryString(params)}`, PATCH_DOCTYPE: ({ code, ...rest }) => `/api/dms/types/${code}?${objectToQueryString(rest)}` } as const satisfies URLDefinition; const Documents = { GET_SEARCH: (params?) => `/api/dms/documents/search?${objectToQueryString(params)}`, GET_DOCUMENT: (documentCode: string) => `/api/dms/documents/${documentCode}`, POST_DOCUMENT: (params) => `/api/dms/documents?${objectToQueryString(params)}`, PATCH_DOCUMENT: ({ documentCode, ...rest }) => `/api/dms/documents/${documentCode}?${objectToQueryString(rest)}` } as const satisfies URLDefinition; const Customers = { GET_LEGAL_CUSTOMER_INFO: (params: { customerNumber?: string; nationalId?: string }) => `/api/Customer/GetLegalCustomerInfo?${objectToQueryString(params)}`, GET_REAL_CUSTOMER_INFO: (params: { customerNumber?: string; nationalCode?: string }) => `/api/Customer/GetRealCustomerInfo?${objectToQueryString(params)}` } as const satisfies URLDefinition; const Gateway = { GET_SHOW_DEPOSIT_SIGNATURE: (filters: { depositNumber: string; amount: number; date: string; identifier: number }) => `/api/wcg/showDepositSignature?${objectToQueryString(filters)}`, POST_EXECUTE_FORMULA_DEPOSIT_SIGNATURE: () => `/api/wcg/executeFormulaDepositSignature` } as const satisfies URLDefinition; export const Services = { General, Common, Properties, Search, SubSystem, DocumentTypes, Documents, Groups, Sima, Customers, Gateway } as const;",
    "convertCategoryData.ts": "export type CategoriesResponseType = { name: string; id: null | number; details: Array<{ code: string; value: string; id: null | number }>; }; export const convertCategoryData = (data: CategoriesResponseType[]) => { return data[0]?.details?.map((item) => ({ label: item.value, value: item.code })) ?? []; };",
    "requireOneOfFields.ts": "import { generalMessages, getFormatMessage } from '@brdp/utils'; import type { RuleRender } from 'antd/es/form'; import { NamePath } from 'antd/es/form/interface'; export const requireOneOfFields = (dependencies: NamePath[]): RuleRender = ({ getFieldValue, setFields }) => ({ validator: (_, value) => { const _value = typeof value === 'string' ? value.trim() : value; const hasEmpty = dependencies.every((name) => { const fieldValue = getFieldValue(name); const dependencyValue = typeof fieldValue === 'string' ? fieldValue.trim() : fieldValue; return !dependencyValue; }); if (!_value && hasEmpty) { setFields(dependencies.map((name) => ({ name, errors: [messages(generalMessages.requireOneOfFields)] }))); return Promise.reject(new Error(messages(generalMessages.requireOneOfFields))); } setFields(dependencies.map((name) => ({ name, errors: undefined }))); return Promise.resolve(); } });",
    "useAppModal.tsx": "import store from '@/store/store'; import { dismissAllModals, ditchModal, hideModal, modalSelector, modalSizes, type ModalSliceType, pushModal } from '@brdp/engine'; import { isFunction } from '@brdp/utils'; import { Flex, Modal } from 'antd'; import { useCallback } from 'react'; import { useDispatch, useSelector } from 'react-redux'; const useAppModal = () => { const dispatch = useDispatch(); const show = showAppModal; const hide = hideAppModal; const ditchAll = ditchAllModal; const Component = useCallback(() => { const modals = useSelector(modalSelector); const modalsList = Object.keys(modals); return modalsList.map((item) => { const { element, id, title, icon, options } = modals[item] as ModalSliceType; const hasOnCancel = isFunction(options?.onCancel); const hasOnOk = isFunction(options?.onOk); const isClosable = options?.closable || false; return ( <Modal key={item} closable={isClosable} open={options?.showing} okText={options?.okText || false} cancelText={options?.cancelText || false} centered title={title ? ( <Flex align='center' justify='flex-start' gap='small'> {icon} {title} </Flex> ) : null} confirmLoading={options?.confirmLoading || false} width={modalSizes[options?.size ?? 'default']} maskClosable={false} keyboard={isClosable} rootClassName='brdp-modal brdp-sima-modal' onCancel={(event) => { if (isFunction(options?.onCancel)) options?.onCancel(event); dispatch(hideModal({ id })); }} onOk={(event) => { if (isFunction(options?.onOk)) options?.onOk(event); }} afterClose={() => { dispatch(ditchModal({ id })); }} footer={(_, { OkBtn, CancelBtn }) => { if (hasOnCancel || hasOnOk) return ( <> {hasOnCancel && <CancelBtn />} {hasOnOk && <OkBtn />} </> ); return null; }}> {element} </Modal> ); }); }, []); return { show, ditchAll, hide, Component }; }; export const showAppModal = ({ title, id, icon, element, options }: ModalSliceType) => { store.dispatch(pushModal({ element, id, title, icon, options: { cancelText: options?.cancelText, okText: options?.okText, closable: options?.closable, confirmLoading: options?.confirmLoading, size: options?.size, showing: options?.showing, onCancel: options?.onCancel, onOk: options?.onOk } })); return () => { hideAppModal(id); }; }; export const hideAppModal = (id: string) => { store.dispatch(hideModal({ id })); }; export const ditchAllModal = () => { store.dispatch(dismissAllModals()); }; export default useAppModal;",
    "index.tsx": "import CustomerSearch from '@/components/business-components/customerSearch/customer-search'; import { Services } from '@/services/url'; import { showAppModal } from '@/utils/hooks/useAppModal'; import { useGet } from '@brdp/engine'; import { ErrorAlert, IconsList, useTablePagination } from '@brdp/ui'; import Content from '@brdp/ui/content'; import { useControlledForm } from '@brdp/ui/form'; import GenerativeTable from '@brdp/ui/generative-table'; import { formatJalaliString, generalMessages, getFormatMessage, removeEmptyValues } from '@brdp/utils'; import React, { useEffect } from 'react'; import simaMessages from '../sima-messages'; import CancelContractModal from './components/modal-forms/cancel-contract-modal'; import EditCustomerIbanModal from './components/modal-forms/edit-customer-iban-modal'; import PrintContractForm from './components/modal-forms/print-contract-form'; import RedeemContract from './components/modal-forms/redeem-contract'; import ShowDetailForm from './components/modal-forms/show-detail-form'; import ShowContractRequests from './components/modal-forms/show-requests'; import TransferContract from './components/modal-forms/transfer-contract'; type ContractsManagementDataType = { contractId: number; customerFullName: string; customerNumber: number; creationDateTime: string; securitiesCode: string; transactionId: string; contractCompleted: boolean; redeemable: boolean; iban: string; customerIdentifier: string; simaTransactionId: string; contractType: string; }; type ContractsManagementFormType = { customerNumber: string; simaTransactionId: string; }; type ContractsManagementResponseType = { result: ContractsManagementDataType[]; pageCount: number; pageIndex: number; pageSize: number; totalCount: number; }; const ContractsManagement: React.FC = () => { const messages = getFormatMessage(); const { tableConfig, pageIndex, PAGE_SIZE, resetPage, tableFromIndex } = useTablePagination(); const { ControlledForm, fieldWatch } = useControlledForm<ContractsManagementFormType>({ id: 'contractsManagementForm' }); const { data: queryData, isFetching: queryFetching, isLoading, mutate } = useGet<ContractsManagementResponseType>(['contracts-management'], Services.Sima.GET_CONTRACTS({ pageIndex, pageSize: PAGE_SIZE, orderBy: 'id', ...removeEmptyValues<Partial<ContractsManagementFormType>>({ customerNumber: fieldWatch('customerNumber'), simaTransactionId: fieldWatch('simaTransactionId') }) }), { enable: false, hasPagination: true }); useEffect(() => { if (queryData?.resultData) mutate(); }, [pageIndex, PAGE_SIZE]); return ( <Content title={messages(simaMessages.contractsManagement)}> <ControlledForm isSubmitting={isLoading} submitLabel={messages(generalMessages.search)} submitButtonIcon={<IconsList.SearchIcon />} onSubmit={() => { mutate(); resetPage(); }} fields={[{ name: 'customerNumber', label: messages(generalMessages.customerNumber), type: 'input' }, { name: 'simaTransactionId', label: messages(simaMessages.simaTransactionId), type: 'input' }]} /> {queryFetching && <Spin />} {queryData?.resultData && <GenerativeTable<ContractsManagementDataType> rowKey='contractId' fromIndex={tableFromIndex} loading={queryFetching} data={queryData.resultData.result || []} pagination={tableConfig(queryData.resultData?.totalCount || 0)} columns={[{ key: 'customerFullName', dataIndex: 'customerFullName', title: messages(generalMessages.customerName) }, { key: 'customerNumber', dataIndex: 'customerNumber', title: messages(generalMessages.customerNumber) }, { key: 'creationDateTime', dataIndex: 'creationDateTime', title: messages(generalMessages.creationDate), render: (value) => formatJalaliString(value || '') }, { key: 'securitiesCode', dataIndex: 'securitiesCode', title: messages(generalMessages.shababCode) }, { key: 'transactionId', dataIndex: 'transactionId', title: messages(generalMessages.transactionNumber) }, { key: 'contractCompleted', dataIndex: 'contractCompleted', title: messages(simaMessages.contractStatus), render: (col) => col ? <IconsList.TickIcon /> : <IconsList.CrossCircleIcon /> }]} rowActions={[{ id: '1', appearance: { icon: <IconsList.EyeIcon />, tooltip: messages(simaMessages.viewContractDetail) }, action: (values) => showAppModal({ id: 'viewContractDetailModal', title: messages(simaMessages.viewContractDetail), element: <ShowDetailForm contractId={values.contractId} />, options: { size: 'default', closable: true } }), disabled: false }, { id: '2', appearance: { icon: <IconsList.EditIcon />, tooltip: messages(simaMessages.editCustomerIban) }, action: (values) => showAppModal({ id: 'editCustomerIbanModal', title: messages(simaMessages.editCustomerIban), element: ( <EditCustomerIbanModal customerNumber={values.customerNumber} customerName={values.customerFullName} customerIdentifier={values.customerIdentifier} securitiesCode={values.securitiesCode} iban={values.iban} contractId={values.contractId} mutateGetContracts={mutate} /> ), options: { size: 'default', closable: true } }), disabled: false }, { id: '3', appearance: { icon: <IconsList.PrinterIcon />, tooltip: messages(simaMessages.printContract) }, action: (values) => showAppModal({ id: 'printContractModal', title: messages(simaMessages.printContract), element: <PrintContractForm contractId={values.contractId} />, options: { closable: true } }), disabled: false }, { id: '4', appearance: { icon: <IconsList.TextDocumentIcon />, tooltip: messages(simaMessages.viewContractRequests) }, action: (values) => showAppModal({ id: 'viewContractRequestsModal', title: messages(simaMessages.viewContractRequests), element: <ShowContractRequests contractId={values.contractId} />, options: { closable: true } }), disabled: false }, { id: '5', appearance: { icon: <IconsList.SendAndGiveIcon />, tooltip: messages(simaMessages.transferContract) }, action: (values) => showAppModal({ id: 'transferContractModal', title: messages(simaMessages.transferContract), element: ( <TransferContract contractId={values.contractId} mutateGetContracts={mutate} /> ), options: { closable: true, size: 'wide' } }) }, { id: '6', appearance: { icon: <IconsList.CrossCircleIcon />, tooltip: messages(simaMessages.cancelContract) }, action: (values) => showAppModal({ id: 'cancelContractModal', title: messages(simaMessages.cancelContract), element: ( <CancelContractModal transactionId={values.transactionId} contractId={values.contractId} mutateGetContracts={mutate} /> ), options: { size: 'small' } }) }, { id: '7', appearance: { icon: <IconsList.RedoIcon />, tooltip: messages(simaMessages.redeemContract) }, action: (values) => showAppModal({ id: 'redeemContractModal', title: messages(simaMessages.redeemContract), element: ( <RedeemContract mutateGetContracts={mutate} contractId={values.contractId} customerNumber={values.customerNumber} /> ), options: { closable: true } }), disabled: (record) => !record.contractCompleted || !record.redeemable }]} /> } </Content> ); }; export default ContractsManagement;",
    "handle-print-contract-form.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import type { PrintContractForm, SimaContractViewDTOSimaContractFormDTOInterestInfoListType } from '../components/modal-forms/print-contract-form'; export const ContractFormPrint = (formData: PrintContractForm, isSale: boolean, title: string, interestList?: SimaContractViewDTOSimaContractFormDTOInterestInfoListType[]) => { const messages = getFormatMessage(); const fieldMap: { [K in keyof PrintContractForm]?: string } = { customerFullName: messages(simaMessages.maleFemale), customerIdentifier: messages(generalMessages.customerId), customerNumber: messages(generalMessages.customerNumber), contractAccountNumber: messages(generalMessages.accountNumber), count: messages(simaMessages.securitiesSheetCount), securitiesCode: messages(simaMessages.securitiesShababCode), creationDateTime: messages(simaMessages.contractDate), dueDate: messages(simaMessages.contractDueDate), transactionNumber: messages(generalMessages.transactionNumber), firstPeriodInterestAmount: messages(simaMessages.firstPeriodReceivedInterest), totalInterestAmount: messages(simaMessages.totalReceivedInterest) }; const tableRows = Object.entries(formData).filter(([key]) => !key.startsWith('divider') && key !== 'table').map(([key, value]) => { const label = fieldMap[key as keyof PrintContractForm] || key; return `<tr><th>${label}</th><td>${value ?? '-'}</td></tr>`; }).join(''); const interestTable = isSale && interestList?.length ? `<hr style=\"margin: 32px 0; border-top: 2px dashed #999\" /><h4 style=\"margin-bottom: 16px;\">${messages(simaMessages.interestInfoListTitle)}</h4><table style=\"width: 100%; border-collapse: collapse;\"><thead><tr><th>${messages(simaMessages.interestReceiptPeriods)}</th><th>${messages(simaMessages.dueInterestAmount, { title: '(ریال)' })}</th><th>${messages(simaMessages.payableInterestAmount, { title: '(ریال)' })}</th></tr></thead><tbody>${interestList.map((item) => `<tr><td>${item.interestReceptionDate ?? '-'}</td><td>${item.interestMatureAmount ?? '-'}</td><td>${item.interestPayAbleAmount ?? '-'}</td></tr>`).join('')}</tbody></table>` : ''; const printWindow = window.open('', '', 'width=900,height=600'); if (!printWindow) return; printWindow.document.write(`<html><head><style>body{font-family:sans-serif;padding:20px;direction:rtl;}h3{text-align:center;margin-bottom:24px;}table{width:100%;margin-bottom:24px;border-collapse:collapse;}th,td{border:1px solid #ccc;padding:8px;font-size:14px;text-align:right;}th{background-color:#f2f2f2;font-weight:bold;width:30%;}</style></head><body><h3>${title}</h3><table><tbody>${tableRows}</tbody></table>${interestTable}</body></html>`); printWindow.document.close(); printWindow.onload = () => { printWindow.focus(); printWindow.print(); printWindow.close(); }; };",
    "redeem-securities-form.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { useGet } from '@brdp/engine'; import { ErrorAlert, Spin } from '@brdp/ui'; import { useControlledForm } from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import React from 'react'; import { RedemptionDataType } from './redeem-securities-detail'; type RedeemSecuritiesFormType = { availableCount: number; customerNumber: number; redemptionCount: number; transactionSource: string; }; type RedeemSecuritiesFormProps = { next: () => void; customerNumber: number; contractId: number; setRedemptionData: React.Dispatch<React.SetStateAction<RedemptionDataType | null>>; }; type RedeemSecuritiesResponseType = { count: number; sources: { id: number; value: string; code: string }[]; }; type RedemptionInterestResponseType = RedemptionDataType; const RedeemSecuritiesForm = ({ next, customerNumber, contractId, setRedemptionData }: RedeemSecuritiesFormProps) => { const messages = getFormatMessage(); const { ControlledForm, fieldWatch } = useControlledForm<RedeemSecuritiesFormType>({ id: 'redeemSecuritiesForm' }); const { data: contractCountData, isFetching: contractCountIsFetching, error: contractCountError } = useGet<RedeemSecuritiesResponseType>(['contract-count', contractId], Services.Sima.GET_COUNT_OF_CONTRACT({ customerNumber, contractId }), { raw: true }); const transactionSources = contractCountData?.resultData?.sources.map((item) => ({ label: item.value, value: item.code })) || []; const { data: redemptionInterestData, isFetching: redemptionInterestIsFetching, error: redemptionInterestError, mutate: redemptionInterestMutate } = useGet<RedemptionInterestResponseType>(['redemption-interest', contractId], Services.Sima.GET_REDEMPTION_INTEREST({ customerNumber, parentContractId: contractId, redemptionCount: fieldWatch('redemptionCount'), redemptionTradingSourceTypeCode: fieldWatch('transactionSource'), availableCount: fieldWatch('availableCount') }), { raw: true, enable: !!fieldWatch('redemptionCount') && !!fieldWatch('transactionSource') } ); const handleNext = () => { if (redemptionInterestData?.resultData) setRedemptionData(redemptionInterestData.resultData); next(); }; useEffect(() => { if (redemptionInterestData?.resultData) setRedemptionData(redemptionInterestData.resultData); }, [redemptionInterestData?.resultData]); if (contractCountIsFetching) return <Spin />; return ( <> {contractCountError && <ErrorAlert errorMessage={contractCountError?.message || messages(generalMessages.errorBadHappened)} />} {contractCountData?.isSuccess === false && <ErrorAlert errorMessage={contractCountData?.message || messages(generalMessages.errorBadHappened)} />} {redemptionInterestError && <ErrorAlert errorMessage={redemptionInterestError?.message || messages(generalMessages.errorBadHappened)} />} {redemptionInterestData?.isSuccess === false && <ErrorAlert errorMessage={redemptionInterestData?.message || messages(generalMessages.errorBadHappened)} />} <ControlledForm onSubmit={handleNext} isLoading={redemptionInterestIsFetching || contractCountIsFetching} submitLabel={messages(generalMessages.next)} reset resetLabel={messages(generalMessages.cancel)} onReset={() => hideAppModal('redeemContractModal')} initialValues={{ availableCount: contractCountData?.resultData?.count, customerNumber }} fields={[{ name: 'availableCount', label: messages(simaMessages.redeemSecuritiesCount), type: 'input', disabled: true, layout: { span: 2 } }, { name: 'customerNumber', label: messages(generalMessages.customerNumber), type: 'input', disabled: true, layout: { span: 2 } }, { name: 'redemptionCount', label: messages(generalMessages.count), type: 'input', layout: { span: 2 }, validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }, { pattern: /^[0-9]{1,18}$/, message: messages(generalMessages.invalidDigitCount) }] } }, { name: 'transactionSource', label: messages(simaMessages.transactionSource), type: 'select', data: { static: transactionSources }, layout: { span: 2 }, options: { placeholder: messages(generalMessages.doChoose) }, validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }] } }]} /> </> ); }; export default RedeemSecuritiesForm;",
    "redeem-securities-detail.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, usePost } from '@brdp/engine'; import { ErrorAlert } from '@brdp/ui'; import FormGenerator, { useControlledForm } from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; export type RedemptionDataType = { customerName: string; customerIdentifier: string; tradingSource: { value: string }; count: number; simaSecuritiesViewDTO: { code: string; name: string; status: { value: string }; principalIban: null | string; interestIban: null | string; groupCode: string; groupDescription: string; sellingStartDateFeature: string; sellingEndDateFeature: string; securitiesDuration: string; securitiesDurationUnit: string; interestPaymentIntervalFeature: number; interestPaymentIntervalUnitFeature: { value: string }; couponRate: number; redemptionRate: number; finalRateOfReturnFeature: null | number; redemptionRateUnitFeature: { value: string }; couponRateUnitFeature: { value: string }; finalRateOfReturnFeatureUnitFeature: { value: string }; redeemable: boolean; transferable: boolean; issueSubject: null | string; guarantor: null | string; trustee: null | string; obligor: null | string; issuer: null | string; isSpecial: boolean; currencyDTO: { currencyName: string }; }; currentDate: string; redemptionAmount: number; redemptionInterestAmount: number; redemptionPenaltyAmount: number; description: string | null; }; type RedeemSecuritiesDetailProps = { prev: () => void; redemptionData: RedemptionDataType | null; mutateGetContracts: () => void; }; type RedeemSecuritiesDetailFormType = { customerName: string; customerIdentifier: string; count: number; tradingSource: string; currentDate: string; securitiesDetailCollapse: string; securitiesCode: string; securitiesName: string; status: string; principalIban: string | null; interestIban: string | null; securitiesGroupCode: string; securitiesGroupName: string; sellingStartDateFeature: string; sellingEndDateFeature: string; securitiesDuration: string; securitiesDurationUnit: string; interestPaymentIntervalFeature: string; redemptionRate: string; couponRate: string; finalRateOfReturnFeature: string; redeemable: string; transferable: string; securitiesType: string; issueSubject: string; guarantor: string; trustee: string; obligor: string; issuer: string; resultDivider: string; redemptionInterestAmount: number; redemptionPenaltyAmount: number; redemptionAmount: number; description: string; }; type RedeemSecuritiesDataType = { customerNumber: number; parentContractId: number; redemptionCount: number; redemptionTradingSourceTypeCode: string; availableCount: number; }; type RedeemSecuritiesResponseType = string; const RedeemSecuritiesDetail = ({ prev, redemptionData, mutateGetContracts }: RedeemSecuritiesDetailProps) => { const messages = getFormatMessage(); const { ControlledForm } = useControlledForm<RedeemSecuritiesDetailFormType>({ id: 'redeemSecuritiesDetailForm' }); const { data, isLoading, mutate, error } = usePost<RedeemSecuritiesResponseType, RedeemSecuritiesDataType>(Services.Sima.POST_REDEEM_SECURITIES, { raw: true }); const handleFinish = (values: RedeemSecuritiesDetailFormType) => { if (redemptionData) { const data = { customerNumber: redemptionData.customerNumber, parentContractId: redemptionData.parentContractId, redemptionCount: redemptionData.count, redemptionTradingSourceTypeCode: redemptionData.tradingSource.code, availableCount: redemptionData.availableCount, description: values.description }; mutate(data).then((result) => { if (result?.isSuccess) { showToast({ title: messages(simaMessages.redeemContract), description: result?.resultData || messages(generalMessages.hasSuccessResponse) }, 'success'); mutateGetContracts(); hideAppModal('redeemContractModal'); } }); } }; if (!redemptionData) return <ErrorAlert errorMessage={messages(generalMessages.errorBadHappened)} />; return ( <> {error && <ErrorAlert errorMessage={error.message || messages(generalMessages.errorBadHappened)} />} {data?.isSuccess === false && <ErrorAlert errorMessage={data?.message || messages(generalMessages.errorBadHappened)} />} <ControlledForm isSubmitting={isLoading} onSubmit={handleFinish} submitLabel={messages(generalMessages.submit)} reset resetLabel={messages(generalMessages.back)} onReset={prev} fields={[{ name: 'securitiesDetailCollapse', label: messages(simaMessages.securitiesDetail), type: 'business', element: FormGenerator.CollapseField, layout: { span: 4 }, options: { extraProps: { fields: [{ name: 'customerName', label: messages(simaMessages.customerName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerIdentifier', label: messages(generalMessages.customerId), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'count', label: messages(generalMessages.count), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'tradingSource', label: messages(simaMessages.transactionSource), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'currentDate', label: messages(generalMessages.date), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesCode', label: messages(generalMessages.shababCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesName', label: messages(simaMessages.securitiesName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'status', label: messages(simaMessages.securitiesStatus), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'principalIban', label: messages(simaMessages.paymentSheba), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'interestIban', label: messages(simaMessages.profitPaymentSheba), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesGroupCode', label: messages(simaMessages.securitiesGroupCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesGroupName', label: messages(simaMessages.securitiesGroupName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'sellingStartDateFeature', label: messages(simaMessages.saleStartDate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'sellingEndDateFeature', label: messages(simaMessages.sellingEndDateTo), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesDuration', label: messages(simaMessages.securitiesDuration), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesDurationUnit', label: messages(simaMessages.securitiesDurationUnit), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'interestPaymentIntervalFeature', label: messages(simaMessages.interestPaymentIntervalFeature), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'interestPaymentIntervalUnitFeature', label: messages(simaMessages.interestPaymentIntervalUnitFeature), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'redemptionRate', label: messages(simaMessages.redemptionRate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'redemptionRateUnitFeature', label: messages(simaMessages.redemptionRateUnitFeature), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'couponRate', label: messages(simaMessages.couponRate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'couponRateUnitFeature', label: messages(simaMessages.couponRateUnitFeature), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'finalRateOfReturnFeature', label: messages(simaMessages.finalRateOfReturnFeature), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'finalRateOfReturnFeatureUnitFeature', label: messages(simaMessages.finalRateOfReturnFeatureUnitFeature), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'redeemable', label: messages(simaMessages.redeemable), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'transferable', label: messages(simaMessages.transferable), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesType', label: messages(simaMessages.securitiesType), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'issueSubject', label: messages(simaMessages.publicationSubject), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'trustee', label: messages(simaMessages.trusteeName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'obligor', label: messages(simaMessages.sponserName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'guarantor', label: messages(simaMessages.guarantorName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'issuer', label: messages(simaMessages.publisherName), type: 'input', readOnly: true, layout: { span: 2 } }] } } }, { name: 'resultDivider', label: '', type: 'divider' }, { name: 'redemptionInterestAmount', label: messages(simaMessages.redeemProfitAmount), type: 'business', element: FormGenerator.AmountField, options: { extraProps: { addonAfter: redemptionData?.simaSecuritiesViewDTO?.currencyDTO.currencyName } }, readOnly: true, layout: { span: 2 } }, { name: 'redemptionPenaltyAmount', label: messages(simaMessages.redeemFineAmount), type: 'business', element: FormGenerator.AmountField, options: { extraProps: { addonAfter: redemptionData?.simaSecuritiesViewDTO?.currencyDTO.currencyName } }, readOnly: true, layout: { span: 2 } }, { name: 'redemptionAmount', label: messages(simaMessages.redeemRecieveAmount), type: 'business', element: FormGenerator.AmountField, options: { extraProps: { addonAfter: redemptionData?.simaSecuritiesViewDTO?.currencyDTO.currencyName } }, readOnly: true, layout: { span: 4 } }, { name: 'description', label: messages(generalMessages.description), type: 'textarea', layout: { span: 2 } }]} /> </> ); }; export default RedeemSecuritiesDetail;",
    "transfer-contract.tsx": "import { Steps } from '@brdp/ui'; import { getFormatMessage } from '@brdp/utils'; import { useState } from 'react'; import simaMessages from '../../../sima-messages'; import TransferContractForm from './transfer-contract-form'; import TransferSecuritiesForm from './transfer-securities-form'; import SignatureModal from './signature-modal'; type TransferContractProps = { contractId: number; mutateGetContracts: () => void; }; export type TransferContractDataType = { customerNumber: number; outDateInterest: number; shababCode: string; countOfPapers: number; count: number; parentContractId: number; buyerCustomerNumber: string; buyerDepositNumber: string; totalAmount: number; }; const TransferContract = ({ contractId, mutateGetContracts }: TransferContractProps) => { const messages = getFormatMessage(); const [current, setCurrent] = useState<number>(0); const [transferData, setTransferData] = useState<TransferContractDataType>({ customerNumber: 0, outDateInterest: 0, shababCode: '', countOfPapers: 0, count: 0, parentContractId: 0, buyerCustomerNumber: '', buyerDepositNumber: '', totalAmount: 0 }); const next = () => setCurrent((prev) => prev + 1); const prev = () => setCurrent((prev) => prev - 1); const steps = [{ title: messages(simaMessages.transferContract), content: ( <TransferContractForm next={next} contractId={contractId} setTransferData={setTransferData} /> ) }, { title: messages(simaMessages.gateway), content: <SignatureModal prev={prev} next={next} transferData={transferData} /> }, { title: messages(simaMessages.transferSecurities), content: ( <TransferSecuritiesForm prev={prev} transferData={transferData} mutateGetContracts={mutateGetContracts} /> ) }]; return ( <> <Steps current={current} steps={steps} /> </> ); }; export default TransferContract;",
    "signature-modal.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { showToast, useGet, usePost } from '@brdp/engine'; import { ErrorAlert, GenerativeTable, Spin, useTablePagination } from '@brdp/ui'; import FormGenerator from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { Image } from 'antd'; import { useState } from 'react'; import { type TransferContractDataType } from './transfer-contract'; const SignatureModal = ({ prev, next, transferData }: { prev: () => void; next: () => void; transferData: TransferContractDataType; }) => { const messages = getFormatMessage(); const [selectedRowsData, setSelectedRowsData] = useState<SignatureTableItem[]>([]); const { tableConfig, tableFromIndex } = useTablePagination(); const nowDate = new Intl.DateTimeFormat('fa-IR', { timeZone: 'Asia/Tehran', year: 'numeric', month: '2-digit', day: '2-digit', numberingSystem: 'latn' }).format(new Date()); const { data: showDepositQueryData, isFetching: showDepositIsFetching } = useGet<ShowDepositResponseType>(['show-deposit-signature'], Services.Gateway.GET_SHOW_DEPOSIT_SIGNATURE({ depositNumber: transferData?.buyerDepositNumber, amount: transferData?.totalAmount, date: nowDate.toString(), identifier: 1 })); const { data: executeData, isLoading: executeLoading, mutate: executeMutate, error: executeError } = usePost<PostExecuteFormulaResponseType, ExecutePropType>(Services.Gateway.POST_EXECUTE_FORMULA_DEPOSIT_SIGNATURE, { raw: true }); const tableData = (result: ShowDepositResponseType): SignatureTableItem[] => { return (result.depositSignaturesInfoVOS?.[0]?.depositFormulaSignatureInfoList?.flatMap((formula) => formula.customerFormulaSignaturesInfoList.map((customer) => ({ key: customer?.signatureDetailsInfoList?.[0]?.signatureId?.toString(), customerName: customer.customerFullName, depositSignatures: `data:image/png;base64,${customer?.signatureDetailsInfoList?.[0]?.signatureWithBase64Format || ''}`, rawCustomerData: customer, rawFormula: formula, depositNumber: result.depositNumber, amount: result.amount, identifier: result.identifier, date: result?.date }))) ?? []; }; const handleNext = () => { if (!selectedRowsData.length) { showToast({ title: messages(simaMessages.signatureChoice), description: '' }, 'error'); return; } const debtorSignatureInfoDtoList = selectedRowsData.map((row) => { const { rawCustomerData, date, depositNumber, amount, identifier } = row; const observedSignatures = rawCustomerData.signatureDetailsInfoList?.map((sig) => `${sig.signatureId}*${depositNumber}*${identifier}`)?.join('|') || ''; return { depositNumber, amount, observedSignatures, selectedFormula: date }; }); const payload: ExecutePropType = { debtorSignatureInfoDtoList, indexList: selectedRowsData.map((row) => Number(row.identifier)) }; executeMutate(payload).then((e) => !!e.resultData && e.resultData?.executionFormulaSignatureDTOList?.length > 0 && next()); }; if (showDepositIsFetching) return <Spin caption={messages(generalMessages.isFetchingData)} />; if (showDepositQueryData?.resultData) return ( <> {executeError && <ErrorAlert errorMessage={executeError.message} />} {executeData?.isSuccess === false && <ErrorAlert errorMessage={executeData?.message || messages(generalMessages.errorBadHappened)} />} <FormGenerator<FormType> id='SignatureModalForm' submitLabel={messages(generalMessages.continue)} onSubmit={handleNext} isLoading={showDepositIsFetching} isSubmitting={executeLoading} reset resetLabel={messages(generalMessages.back)} onReset={prev} initialValues={{ withdrawalDescription: showDepositQueryData.resultData.depositSignaturesInfoVOS?.[0]?.withdrawDescription ?? '', amount: showDepositQueryData.resultData.amount, date: showDepositQueryData.resultData.date, withdrawalCondition: showDepositQueryData.resultData.depositSignaturesInfoVOS?.[0]?.depositFormulaSignatureInfoList?.[0]?.description ?? '' }} fields={[{ name: 'withdrawalDescription', label: messages(simaMessages.withdrawalDescription), type: 'input', layout: { span: 2 }, disabled: true }, { name: 'amount', label: messages(generalMessages.amount), type: 'business', element: FormGenerator.AmountField, disabled: true }, { name: 'date', label: messages(generalMessages.date), type: 'input', disabled: true }, { name: 'withdrawalCondition', label: messages(simaMessages.withdrawalCondition), type: 'input', disabled: true, layout: { span: 2 } }]} /> <GenerativeTable<SignatureTableItem> rowKey='depositSignatures' fromIndex={tableFromIndex} loading={showDepositIsFetching} pagination={tableConfig(0)} rowSelection={{ type: 'multiple', onChange: (_selectedRowKeys, selectedRows) => setSelectedRowsData(selectedRows) }} data={showDepositQueryData?.resultData ? tableData(showDepositQueryData?.resultData) : []} columns={[{ title: messages(simaMessages.customerName), dataIndex: 'customerName', key: 'customerName' }, { title: messages(simaMessages.depositSignatures), dataIndex: 'depositSignatures', key: 'depositSignatures', render: (record) => <Image src={record} width={100} /> }]} /> </> ); return <ErrorAlert errorMessage={showDepositQueryData?.message || messages(generalMessages.errorBadHappened)} />; }; export default SignatureModal; export type DepositSignaturesInfoVO = { identifier: string; depositNumber: string; withdrawDescription: string; canChangeFormulaSignatureDate: boolean; defaultFormulaSignatureDate: string; depositFormulaSignatureInfoList: DepositFormulaSignatureInfo[]; customerRelationWithOtherCustomersInfo: null | { customerNumber: number; otherCustomerInfoMap: { entry: { string: string; list: string } } } }; export type ShowDepositResponseType = { depositNumber: string; amount: number; date: string; identifier: string; depositSignaturesInfoVOS: DepositSignaturesInfoVO[] }; export type ExecutePropType = { debtorSignatureInfoDtoList: { depositNumber: string; amount: number; observedSignatures: string; selectedFormula: string }[]; indexList: number[] }; export type ValidateSalePropType = { depositNumber: string; totalAmount: number }; export type FormType = { withdrawalDescription: string; amount: number; date: string; withdrawalCondition: string; table?: unknown }; export type SignatureTableItem = { key: string; customerName: string; depositSignatures: string; rawCustomerData: CustomerFormulaSignatureInfo; rawFormula: DepositFormulaSignatureInfo; depositNumber: string; amount: number; identifier: string; date: string }; export type PostExecuteFormulaResponseType = { rsCode: string; transactionCode: string; otherValues: []; errorMessage: string; responseTimeMillis: number; requestId: string; requestDateTime: string; responseDateTime: string; executionFormulaSignatureDTOList: ExecutionFormulaSignatureDTOListType[] }; export type ExecutionFormulaSignatureDTOListType = { withdrawRight: boolean; depositNumber: string; date: null | string; customerNumbers: null | number[]; rsCode: string; transactionCode: string; otherValues: []; errorMessage: string; responseTimeMillis: number; requestId: string; requestDateTime: null | string; responseDateTime: null | string; executedSignatures: null | string; response: null | string; otherValue: [] };",
    "show-requests.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { useGet } from '@brdp/engine'; import { ErrorAlert, Typography, useTablePagination } from '@brdp/ui'; import GenerativeTable from '@brdp/ui/generative-table'; import { formatJalaliString, generalMessages, getFormatMessage } from '@brdp/utils'; import { Tag } from 'antd'; type ContractRequestsDataType = { serviceType: string; requestStatus: string; requestSendDateAndTime: string; responseAckStatus: string; responseSendDateAndTime: string; responseErrors: { code: string; message: string }[] }; type ContractRequestsResponseType = { result: ContractRequestsDataType[]; pageCount: number; pageIndex: number; pageSize: number; totalCount: number; }; const ShowContractRequests = ({ contractId }: { contractId: number }) => { const messages = getFormatMessage(); const { tableConfig, tableFromIndex } = useTablePagination(); const { data: queryData, isFetching: queryFetching } = useGet<ContractRequestsResponseType>(['contract-requests'], Services.Sima.GET_CONTRACT_REQUESTS(contractId), { hasPagination: true }); const convertedQueryData = queryData?.resultData.result.map((item, index) => ({ ...item, id: index + 1 })) || []; return ( <> {queryData?.isSuccess === false && <ErrorAlert errorMessage={queryData?.message || messages(generalMessages.errorBadHappened)} />} <GenerativeTable<ContractRequestsDataType> rowKey='id' fromIndex={tableFromIndex} data={convertedQueryData || []} loading={queryFetching} pagination={tableConfig(queryData?.resultData.totalCount || 0)} columns={[{ key: 'serviceType', dataIndex: 'serviceType', title: messages(simaMessages.requestType) }, { key: 'requestStatus', dataIndex: 'requestStatus', title: messages(simaMessages.requestStatus) }, { key: 'requestSendDateAndTime', dataIndex: 'requestSendDateAndTime', title: messages(simaMessages.sendRequestDate), render: (col) => col ? formatJalaliString(col) : '' }, { key: 'responseAckStatus', dataIndex: 'responseAckStatus', title: messages(simaMessages.responseStatus), render: (col) => col ? ( <Tag color='green'>{messages(generalMessages.successful)}</Tag> ) : ( <Tag color='volcano'>{messages(generalMessages.unsuccessful)}</Tag> ) }, { key: 'responseSendDateAndTime', dataIndex: 'responseSendDateAndTime', title: messages(simaMessages.sendResponseDate), render: (col) => col ? formatJalaliString(col) : '' }, { key: 'responseErrors', dataIndex: 'responseErrors', title: messages(simaMessages.responseErrorsDetails), render: (col) => col && !!col.length ? ( <Typography text={messages(generalMessages.has)} /> ) : ( <Typography text={messages(generalMessages.doesNotHave)} /> ) }]} /> </> ); }; export default ShowContractRequests;",
    "transfer-contract-form.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { useGet } from '@brdp/engine'; import { ErrorAlert, Spin } from '@brdp/ui'; import { useControlledForm } from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { TransferContractDataType } from './transfer-contract'; type TransferContractFormType = { customerNumber: number; interestMatureAmount: number; securitiesCode: string; securitiesTotalCount: number; buyerCustomerNumber: string; count: number; buyerDepositNumber: string; }; type ContractViewResponseType = { customerNumber: number; securitiesCode: string; count: number; redemptionInterestAmount: number; }; type ContractTransferValidationResponseType = { simaSecuritiesViewDTO: { parValueFeature: number }; }; type TransferContractFormProps = { next: () => void; contractId: number; setTransferData: React.Dispatch<React.SetStateAction<TransferContractDataType>>; }; const TransferContractForm = ({ next, contractId, setTransferData }: TransferContractFormProps) => { const messages = getFormatMessage(); const { ControlledForm, fieldWatch } = useControlledForm<TransferContractFormType>({ id: 'transferContractForm' }); const { data: contractViewData, isFetching: contractViewIsFetching, error: contractViewError } = useGet<ContractViewResponseType>(['contract-view', contractId], Services.Sima.GET_COTRACT_VIEW(contractId), { raw: true }); const { data: validationData, isFetching: validationIsFetching, error: validationError, mutate: validationMutate } = useGet<ContractTransferValidationResponseType>(['contract-transfer-validation', contractId], Services.Sima.GET_CONTRACT_TRANSFER_VALIDATION({ customerNumber: fieldWatch('customerNumber'), outDateInterest: fieldWatch('interestMatureAmount'), shababCode: fieldWatch('securitiesCode'), countOfPapers: fieldWatch('securitiesTotalCount'), count: fieldWatch('count'), parentContractId: contractId, buyerCustomerNumber: fieldWatch('buyerCustomerNumber'), buyerDepositNumber: fieldWatch('buyerDepositNumber') }), { raw: true, enable: !!fieldWatch('buyerCustomerNumber') && !!fieldWatch('count') && !!fieldWatch('buyerDepositNumber') } ); const handleNext = () => { if (validationData?.resultData) { setTransferData({ customerNumber: contractViewData?.resultData?.customerNumber, outDateInterest: contractViewData?.resultData?.redemptionInterestAmount, shababCode: contractViewData?.resultData?.securitiesCode, countOfPapers: contractViewData?.resultData?.count, count: fieldWatch('count'), parentContractId: contractId, buyerCustomerNumber: fieldWatch('buyerCustomerNumber'), buyerDepositNumber: fieldWatch('buyerDepositNumber'), totalAmount: validationData?.resultData?.simaSecuritiesViewDTO?.parValueFeature * fieldWatch('count') }); } next(); }; useEffect(() => { if (validationData?.resultData) validationMutate({ customerNumber: fieldWatch('customerNumber'), outDateInterest: fieldWatch('interestMatureAmount'), shababCode: fieldWatch('securitiesCode'), countOfPapers: fieldWatch('securitiesTotalCount'), count: fieldWatch('count'), parentContractId: contractId, buyerCustomerNumber: fieldWatch('buyerCustomerNumber'), buyerDepositNumber: fieldWatch('buyerDepositNumber') }); }, [fieldWatch('buyerCustomerNumber'), fieldWatch('count'), fieldWatch('buyerDepositNumber')]); if (contractViewIsFetching) return <Spin />; return ( <> {contractViewError && <ErrorAlert errorMessage={contractViewError?.message || messages(generalMessages.errorBadHappened)} />} {contractViewData?.isSuccess === false && <ErrorAlert errorMessage={contractViewData?.message || messages(generalMessages.errorBadHappened)} />} {validationError && <ErrorAlert errorMessage={validationError?.message || messages(generalMessages.errorBadHappened)} />} {validationData?.isSuccess === false && <ErrorAlert errorMessage={validationData?.message || messages(generalMessages.errorBadHappened)} />} <ControlledForm onSubmit={handleNext} isLoading={validationIsFetching || contractViewIsFetching} submitLabel={messages(generalMessages.next)} reset resetLabel={messages(generalMessages.cancel)} onReset={() => hideAppModal('transferContractModal')} initialValues={{ customerNumber: contractViewData?.resultData?.customerNumber, interestMatureAmount: contractViewData?.resultData?.redemptionInterestAmount, securitiesCode: contractViewData?.resultData?.securitiesCode, securitiesTotalCount: contractViewData?.resultData?.count }} fields={[{ name: 'customerNumber', label: messages(generalMessages.customerNumber), type: 'input', disabled: true, layout: { span: 2 } }, { name: 'interestMatureAmount', label: messages(simaMessages.interestMatureAmount), type: 'input', disabled: true, layout: { span: 2 } }, { name: 'securitiesCode', label: messages(generalMessages.shababCode), type: 'input', disabled: true }, { name: 'securitiesTotalCount', label: messages(simaMessages.securitiesTotalCount), type: 'input', disabled: true }, { name: 'buyerCustomerNumber', label: messages(simaMessages.buyerCustomerNumber), type: 'input', validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }, { pattern: /^[0-9]{1,18}$/, message: messages(generalMessages.invalidDigitCount) }] } }, { name: 'count', label: messages(generalMessages.count), type: 'input', validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }, { pattern: /^[0-9]{1,18}$/, message: messages(generalMessages.invalidDigitCount) }] } }, { name: 'buyerDepositNumber', label: messages(simaMessages.depositNumber), type: 'input', validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }] } }]} /> </> ); }; export default TransferContractForm;",
    "redeem-contract.tsx": "import { Steps } from '@brdp/ui'; import { getFormatMessage } from '@brdp/utils'; import { useState } from 'react'; import simaMessages from '../../../sima-messages'; import RedeemSecuritiesForm from './redeem-securities-form'; import RedeemSecuritiesDetail, { RedemptionDataType } from './redeem-securities-detail'; type RedeemContractProps = { mutateGetContracts: () => void; customerNumber: number; contractId: number; }; const RedeemContract = ({ mutateGetContracts, contractId, customerNumber }: RedeemContractProps) => { const messages = getFormatMessage(); const [current, setCurrent] = useState<number>(0); const [redemptionData, setRedemptionData] = useState<RedemptionDataType | null>(null); const next = () => setCurrent((value) => value + 1); const prev = () => setCurrent((value) => value - 1); const steps = [{ title: messages(simaMessages.redeemSecurities), content: ( <RedeemSecuritiesForm next={next} contractId={contractId} customerNumber={customerNumber} setRedemptionData={setRedemptionData} /> ) }, { title: messages(simaMessages.redeemSecurities), content: ( <RedeemSecuritiesDetail prev={prev} redemptionData={redemptionData} mutateGetContracts={mutateGetContracts} /> ) }]; return ( <> <Steps current={current} steps={steps} /> </> ); }; export default RedeemContract;",
    "print-contract-form.tsx": "import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { useGet } from '@brdp/engine'; import { ErrorAlert, FormGenerator, GenerativeTable, Spin, useTablePagination } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import simaMessages from '../../../sima-messages'; import { ContractFormPrint } from '../../utils/handle-print-contract-form'; const PrintContractForm = ({ contractId }: { contractId: number }) => { const messages = getFormatMessage(); const { tableConfig, tableFromIndex } = useTablePagination(); const { data, isFetching } = useGet<PrintContractResponseType>(['perforation-contract'], Services.Sima.GET_PERFORATION_CONTRACT(contractId)); const initialData = { customerFullName: data?.resultData?.simaContractViewDTO?.customerFullName || '', customerIdentifier: data?.resultData?.simaContractViewDTO?.customerIdentifier || '', customerNumber: data?.resultData?.simaContractViewDTO?.customerNumber || '', contractAccountNumber: data?.resultData?.simaContractViewDTO?.contractAccountNumber || '', count: data?.resultData?.simaContractViewDTO?.count || 0, securitiesCode: data?.resultData?.simaContractViewDTO?.securitiesCode || '', creationDateTime: data?.resultData?.simaContractViewDTO?.creationDateTime || '', dueDate: data?.resultData?.simaContractViewDTO?.dueDate || '', transactionNumber: data?.resultData?.simaContractViewDTO?.transactionNumber || '', firstPeriodInterestAmount: data?.resultData?.simaContractViewDTO?.simaContractFormDTO?.firstPeriodInterestAmount, totalInterestAmount: data?.resultData?.simaContractViewDTO?.simaContractFormDTO?.totalInterestAmount }; const renderTable = () => ( <GenerativeTable<SimaContractViewDTOSimaContractFormDTOInterestInfoListType> rowKey='key' fromIndex={tableFromIndex} data={data?.resultData?.simaContractViewDTO?.simaContractFormDTO?.interestInfoList?.map((item, index) => ({ ...item, key: index })) ?? []} pagination={tableConfig(0)} columns={[{ key: 'interestReceptionDate', dataIndex: 'interestReceptionDate', title: messages(simaMessages.interestReceiptPeriods) }, { key: 'interestMatureAmount', dataIndex: 'interestMatureAmount', title: messages(simaMessages.dueInterestAmount, { title: '(ریال)' }) }, { key: 'interestPayAbleAmount', dataIndex: 'interestPayAbleAmount', title: messages(simaMessages.payableInterestAmount, { title: '(ریال)' }) }]} /> ); if (isFetching) return <Spin caption={messages(generalMessages.isFetchingData)} />; if (data?.resultData && data?.isSuccess) return ( <FormGenerator<PrintContractForm> id={'printContractForm'} submitLabel={messages(generalMessages.print)} onSubmit={() => ContractFormPrint(initialData, data?.resultData?.simaContractViewDTO?.contractType.includes(messages(simaMessages.sale)), data?.resultData?.simaContractViewDTO?.contractType, data?.resultData?.simaContractViewDTO?.simaContractFormDTO?.interestInfoList)} resetLabel={messages(generalMessages.cancel)} onReset={() => hideAppModal('printContractModal')} initialValues={initialData} fields={data?.resultData?.simaContractViewDTO?.contractType.includes(messages(simaMessages.sale)) ? [{ name: 'customerFullName', label: messages(simaMessages.maleFemale), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerIdentifier', label: messages(generalMessages.customerId), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerNumber', label: messages(generalMessages.customerNumber), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'contractAccountNumber', label: messages(generalMessages.accountNumber), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'count', label: messages(simaMessages.securitiesSheetCount), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesCode', label: messages(simaMessages.securitiesShababCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'creationDateTime', label: messages(simaMessages.contractDate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'dueDate', label: messages(simaMessages.contractDueDate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'transactionNumber', label: messages(generalMessages.transactionNumber), type: 'input', readOnly: true, layout: { span: 4 } }, { name: 'divider1', label: '', type: 'divider' }, { name: 'firstPeriodInterestAmount', label: messages(simaMessages.firstPeriodReceivedInterest), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'totalInterestAmount', label: messages(simaMessages.totalReceivedInterest), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'divider2', label: '', type: 'divider' }, { name: 'table', label: '', type: 'business', element: renderTable, layout: { span: 4 } }] : [{ name: 'customerFullName', label: messages(simaMessages.maleFemale), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerIdentifier', label: messages(generalMessages.customerId), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerNumber', label: messages(generalMessages.customerNumber), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'contractAccountNumber', label: messages(generalMessages.accountNumber), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'count', label: messages(simaMessages.securitiesSheetCount), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesCode', label: messages(simaMessages.securitiesShababCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'creationDateTime', label: messages(simaMessages.contractDate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'dueDate', label: messages(simaMessages.contractDueDate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'transactionNumber', label: messages(generalMessages.transactionNumber), type: 'input', readOnly: true, layout: { span: 4 } }]} /> ); return <ErrorAlert errorMessage={data?.message || messages(generalMessages.errorBadHappened)} />; }; export default PrintContractForm; export type PrintContractResponseType = { simaContractViewDTO: { securitiesCode: string; securitiesId: number; creationDateTime: string; currentDateTime: string; paidAmount: number; count: number; redemptionInterestAmount: null | number; redemptionPenaltyAmount: null | number; customerNumber: string; customerFullName: string; contractType: string; status: string; dueDate: string; iban: string; contractId: number; transferable: boolean; simaContractFormDTO: { interestInfoList: SimaContractViewDTOSimaContractFormDTOInterestInfoListType[]; firstPeriodInterestAmount: string; totalInterestAmount: string }; customerIdentifier: string; transactionNumber: string; contractAccountNumber: string; description: null | string; currentDate: string; redemptionContract: boolean; simaTransactionId: string; reverseTransactionNumber: null | number }; simaSecuritiesViewDTO: { id: null | number; code: string; name: string; status: { id: number; value: string; code: string }; principalIban: null | string; interestIban: null | string; groupCode: string; groupDescription: string; sellingStartDateFeature: string; sellingEndDateFeature: string; securitiesDuration: string; securitiesDurationUnit: string; interestPaymentIntervalFeature: number; interestPaymentIntervalUnitFeature: { value: string }; couponRate: number; redemptionRate: number; finalRateOfReturnFeature: null | string; redeemable: boolean; transferable: boolean; bondType: null | string; issueSubject: null | string; guarantor: null | string; trustee: null | string; obligor: null | string; issuer: null | string; countFeature: number; parValueFeature: number; totalRedemptedSecuritiesCount: number; totalSaledSecuritiesCount: number; totalResaledSecuritiesCount: number; totalSalableSecuritiesCount: number; interestAmount: number; dailyInterestAmount: number; couponsDate: string[]; isSpecial: boolean; debtorTopicId: null | number; creditorTopicId: null | number; debtorTopicCode: null | string; creditorTopicCode: null | string; depositNumber: null | number; lastSimaTaskItemLog: null | string; special: boolean } }; export type SimaContractViewDTOSimaContractFormDTOInterestInfoListType = { interestReceptionDate: string; interestMatureAmount: string; interestPayAbleAmount: string; isCurrentPeriod: boolean }; export type PrintContractForm = { customerFullName: string; customerIdentifier: string; customerNumber: string; contractAccountNumber: string; count: number; securitiesCode: string; creationDateTime: string; dueDate: string; transactionNumber: string; firstPeriodInterestAmount?: string; totalInterestAmount?: string; divider1?: null; divider2?: null; table?: SimaContractViewDTOSimaContractFormDTOInterestInfoListType };",
    "edit-customer-iban-modal.tsx": "import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, usePut } from '@brdp/engine'; import { ErrorAlert, FormGenerator } from '@brdp/ui'; import { useControlledForm } from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import simaMessages from '../../../sima-messages'; type EditCustomerIbanModalProps = { customerNumber: number; customerName: string; customerIdentifier: string; securitiesCode: string; iban: string; contractId: number; mutateGetContracts: () => void; }; type EditCustomerIbanFormType = { customerNumber: number; customerName: string; securitiesCode: string; iban: string; newIban: string; confirmEditIban: boolean; }; type EditCustomerIbanDataType = { securitiesCode: string; iban: string; customerIdentifier: string; newIban: string; customerNumber: number; }; type EditCustomerIbanResponseType = { message: string }; const EditCustomerIbanModal = ({ customerNumber, customerName, customerIdentifier, securitiesCode, iban, contractId, mutateGetContracts }: EditCustomerIbanModalProps) => { const messages = getFormatMessage(); const { ControlledForm, fieldWatch } = useControlledForm<EditCustomerIbanFormType>({ id: 'editCustomerIbanForm' }); const confirmEditIban = fieldWatch('confirmEditIban'); const { data, mutate, isLoading, error } = usePut<EditCustomerIbanResponseType, EditCustomerIbanDataType>(Services.Sima.UPDATE_IBAN_CONTRACT(contractId), { raw: true }); const handleEditIban = (values: EditCustomerIbanFormType) => { mutate({ securitiesCode, iban, customerNumber, customerIdentifier, ...(confirmEditIban && { newIban: values.newIban }) }).then((result) => { if (result?.isSuccess) { showToast({ title: messages(generalMessages.successful), description: result?.resultData?.message || messages(simaMessages.editIbanSuccessfully) }, 'success'); mutateGetContracts(); hideAppModal('editCustomerIbanModal'); } }); }; return ( <> {error && <ErrorAlert errorMessage={error.message || messages(generalMessages.errorBadHappened)} />} {data?.isSuccess === false && <ErrorAlert errorMessage={data?.message || messages(generalMessages.errorBadHappened)} />} <ControlledForm onSubmit={handleEditIban} submitLabel={messages(generalMessages.confirm)} isSubmitting={isLoading} reset resetLabel={messages(generalMessages.cancel)} onReset={() => { hideAppModal('editCustomerIbanModal'); }} initialValues={{ customerNumber, customerName, securitiesCode, iban }} fields={[{ name: 'customerNumber', label: messages(generalMessages.customerNumber), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesCode', label: messages(generalMessages.shababCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerName', label: messages(generalMessages.customerName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'iban', label: messages(simaMessages.customerSheba), type: 'business', element: FormGenerator.IBANField, readOnly: true, layout: { span: 2 } }, { name: 'confirmEditIban', extra: messages(simaMessages.editIbanWarning, { customerNumber, securitiesCode }), label: messages(simaMessages.confirmEditIban), type: 'checkbox', layout: { span: 4 } }, { name: 'newIban', label: messages(simaMessages.newSheba), type: 'business', element: FormGenerator.IBANField, disabled: !confirmEditIban || isLoading, layout: { span: 2 }, options: { extraProps: { addIR: true } }, validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }, { validator: (_, value) => { const digitsOnly = value?.replace(/^IR/i, '').replace(/[^0-9]/g, '') || ''; if (digitsOnly.length < 24) return Promise.reject(new Error(messages(generalMessages.ibanValidation))); return Promise.resolve(); } }] } }]} /> </> ); }; export default EditCustomerIbanModal;",
    "cancel-contract-modal.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, usePost } from '@brdp/engine'; import { ErrorAlert, FormGenerator, Typography } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { Space } from 'antd'; type CancelContractModalProps = { transactionId: string; contractId: number; mutateGetContracts: () => void; }; type CancelContractFormType = { contractId: number; transactionId: string; }; type CancelContractDataType = { transactionId: string; }; type CancelContractResponseType = string; const CancelContractModal = ({ transactionId, contractId, mutateGetContracts }: CancelContractModalProps) => { const messages = getFormatMessage(); const { error, mutate, isLoading, data } = usePost<CancelContractResponseType, CancelContractDataType>(Services.Sima.POST_CANCEL_CONTRACT(), { raw: true }); const handleCancelContract = (transactionId: string) => { mutate({ transactionId }).then((result) => { if (result?.isSuccess) { hideAppModal('cancelContractModal'); showToast({ title: messages(simaMessages.cancelContract), description: result?.resultData || messages(simaMessages.cancelContractSuccessfully) }, 'success', 'cancelContractSuccessfully'); mutateGetContracts(); } }); }; return ( <Space direction='vertical'> {error && <ErrorAlert errorMessage={error?.message || messages(generalMessages.errorBadHappened)} />} {data?.isSuccess === false && <ErrorAlert errorMessage={data?.message || messages(generalMessages.errorBadHappened)} />} <Typography text={messages(simaMessages.confirmCancelContract)} /> <FormGenerator<CancelContractFormType> id='cancelContractForm' initialValues={{ contractId, transactionId }} isSubmitting={isLoading} submitLabel={messages(generalMessages.confirm)} onSubmit={() => handleCancelContract(transactionId)} reset resetLabel={messages(generalMessages.cancel)} onReset={() => { hideAppModal('cancelContractModal'); }} fields={[{ name: 'contractId', type: 'input', label: messages(simaMessages.contractId), layout: { span: 4 }, readOnly: true }, { name: 'transactionId', type: 'input', label: messages(generalMessages.transactionId), layout: { span: 4 }, readOnly: true }]} /> </Space> ); }; export default CancelContractModal;",
    "allocate-securities.tsx": "import { Services } from '@/services/url'; import { showToast, usePost } from '@brdp/engine'; import { Button, IconsList } from '@brdp/ui'; import { getFormatMessage } from '@brdp/utils'; import simaMessages from '../../sima-messages'; export const useAllocateSecurities = () => { const messages = getFormatMessage(); const { mutate: allocateMutate, isLoading: allocateFetching } = usePost<string>(Services.Sima.POST_ALLOCATE_SECURITIES); const AllocateSecuritiesButton = ({ callback }: { callback: (result: unknown) => void }) => ( <Button type='primary' label={messages(simaMessages.allocateSecurities)} icon={<IconsList.DashboardGridIcon />} onClick={() => { allocateMutate({}).then((result) => { showToast({ title: messages(simaMessages.allocateSecurities), description: result?.resultData }, 'success', 'allocateToast'); callback(result); }); }} loading={allocateFetching} /> ); return { allocateMutate, allocateFetching, AllocateSecuritiesButton }; };",
    "additional-info-form.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, useGet, usePost } from '@brdp/engine'; import { ErrorAlert, Spin } from '@brdp/ui'; import { useControlledForm } from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { useEffect } from 'react'; const AdditionalInfoForm = ({ securitiesCode, mutate }: { securitiesCode: string; mutate: () => void }) => { const messages = getFormatMessage(); const { ControlledForm, fieldWatch, setFieldsValue } = useControlledForm<AdditionalInfoFormType>({ id: 'additionalInfoForm', confirmBeforeClose: true }); const isDeposit = fieldWatch('headingOrDeposit') === 'deposit'; const isHeader = fieldWatch('headingOrDeposit') === 'header'; const { data: depositTopicData, isFetching: depositTopicFetching, isSuccess: depositTopicIsSuccess } = useGet<DepositTopicResponseType | null>(['deposit-topic-info'], Services.Sima.GET_DEPOSIT_TOPIC_INFO(securitiesCode)); const { data: topicInfoData, isFetching: topicInfoFetching } = useGet<TopicInfoResponseType[]>(['topic-info'], Services.Sima.GET_TOPIC_INFO(), { enable: Boolean(!depositTopicData?.isSuccess) && depositTopicIsSuccess }); const debtorHeadings = topicInfoData?.resultData.filter((item) => item.typeCode === 'DEBTOR').map(({ title, code, id }) => ({ label: `${title} (${code})`, value: id })) || []; const creditorHeadings = topicInfoData?.resultData.filter((item) => item.typeCode === 'CREDITOR').map(({ title, code, id }) => ({ label: `${title} (${code})`, value: id })) || []; const { data: topicData, mutate: topicMutate, isLoading: topicIsLoading } = usePost<InterestInfoResponseType, InterestInfoTopicDataType>(Services.Sima.POST_INTEREST_INFO_TOPIC, { raw: true }); const { data: depositData, mutate: depositMutate, isLoading: depositIsLoading } = usePost<InterestInfoResponseType, InterestInfoDepositDataType>(Services.Sima.POST_INTEREST_INFO_DEPOSIT, { raw: true }); const handleOnFinish = async (values: AdditionalInfoFormType) => { if (values?.headingOrDeposit === 'deposit') { const data = { securitiesCode, depositNumber: values.depositNumber }; depositMutate(data).then((res) => { if (res?.isSuccess) { hideAppModal('depositInformationModal'); showToast({ title: messages(generalMessages.successful), description: res?.message || messages(generalMessages.hasSuccessResponse) }, 'success'); mutate(); } }); } else { const creditorTopicCode = topicInfoData?.resultData.filter((item) => item.typeCode === 'CREDITOR' && item.id === Number(values.creditorHeading))?.[0]?.code || ''; const debtorTopicCode = topicInfoData?.resultData.filter((item) => item.typeCode === 'DEBTOR' && item.id === Number(values.debtorHeading))?.[0]?.code || ''; const data = { securitiesCode, creditorTopicCode, debtorTopicCode }; topicMutate(data).then((res) => { if (res?.isSuccess) { hideAppModal('depositInformationModal'); showToast({ title: messages(generalMessages.successful), description: res?.message || messages(generalMessages.hasSuccessResponse) }, 'success'); mutate(); } }); } }; useEffect(() => { if (!!depositTopicData?.resultData?.debtorTopic && !!depositTopicData?.resultData?.creditorTopic) { setFieldsValue({ headingOrDeposit: 'header', debtorHeading: `${depositTopicData?.resultData?.debtorTopic?.title} (${depositTopicData?.resultData?.debtorTopic?.code})`, creditorHeading: `${depositTopicData?.resultData?.creditorTopic?.title} (${depositTopicData?.resultData?.creditorTopic?.code})` }); } else if (depositTopicData?.resultData?.depositNumber) { setFieldsValue({ headingOrDeposit: 'deposit', depositNumber: depositTopicData?.resultData?.depositNumber }); } }, [depositTopicData?.resultData]); if (depositTopicFetching) return <Spin caption={messages(generalMessages.isFetchingData)} />; return ( <> {topicData?.isSuccess === false && <ErrorAlert errorMessage={topicData.message || messages(generalMessages.errorBadHappened)} />} {depositData?.isSuccess === false && <ErrorAlert errorMessage={depositData.message || messages(generalMessages.errorBadHappened)} />} {topicInfoData?.isSuccess === false && <ErrorAlert errorMessage={topicInfoData.message || messages(generalMessages.errorBadHappened)} />} <ControlledForm onSubmit={!depositTopicData?.isSuccess ? handleOnFinish : undefined} isLoading={topicInfoFetching || depositTopicFetching || depositIsLoading || topicIsLoading} isSubmitting={topicIsLoading || depositIsLoading} initialValues={{ headingOrDeposit: 'header' }} fields={[{ name: 'headingOrDeposit', label: '', disabled: !!depositTopicData?.resultData?.depositNumber || !!depositTopicData?.resultData?.creditorTopic || !!depositTopicData?.resultData?.debtorTopic, type: 'select', options: { placeholder: messages(generalMessages.doChoose) }, layout: { span: 4 }, data: { static: [{ label: messages(simaMessages.headerInfo), value: 'header' }, { label: messages(simaMessages.depositInfo), value: 'deposit' }] } }, { name: 'debtorHeading', label: messages(simaMessages.debtorHeading), type: 'select', loading: topicInfoFetching, options: { placeholder: messages(generalMessages.doChoose), searchable: true }, hidden: isDeposit, readOnly: !!depositTopicData?.resultData?.depositNumber || !!depositTopicData?.resultData?.creditorTopic || !!depositTopicData?.resultData?.debtorTopic, layout: { span: 2 }, data: { static: debtorHeadings }, dependencies: ['headingOrDeposit'] }, { name: 'creditorHeading', label: messages(simaMessages.creditorHeading), type: 'select', loading: topicInfoFetching, options: { placeholder: messages(generalMessages.doChoose), searchable: true }, hidden: isDeposit, readOnly: !!depositTopicData?.resultData?.depositNumber || !!depositTopicData?.resultData?.creditorTopic || !!depositTopicData?.resultData?.debtorTopic, layout: { span: 2 }, data: { static: creditorHeadings } }, { name: 'depositNumber', label: messages(simaMessages.depositNumber), type: 'input', layout: { span: 2 }, hidden: isHeader, readOnly: !!depositTopicData?.resultData?.depositNumber || !!depositTopicData?.resultData?.creditorTopic || !!depositTopicData?.resultData?.debtorTopic }]} submitLabel={messages(generalMessages.submit)} /> </> ); }; export default AdditionalInfoForm; export type TopicInfoResponseType = { id: number; code: string; title: string; openableAccountNumberCode: string; typeCode: string; oppositeTopic: number | null }; type DepositTopicTypes = { id: number; code: string; title: string; openableAccountNumberCode: string; typeCode: 'DEBTOR' | 'CREDITOR'; oppositeTopic: number }; export type DepositTopicResponseType = { code: null | string; creditorTopic: null | DepositTopicTypes; debtorTopic: null | DepositTopicTypes; depositNumber: null | string }; export type AdditionalInfoFormType = { headingOrDeposit: string; debtorHeading: string; creditorHeading: string; depositNumber: string }; export type InterestInfoTopicDataType = { securitiesCode: string; creditorTopicCode: string; debtorTopicCode: string }; export type InterestInfoDepositDataType = { securitiesCode: string; depositNumber: string }; export type InterestInfoResponseType = [];",
    "edit-detail-form.tsx": "import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { CategoriesResponseType, convertCategoryData } from '@/utils/convertCategoryData'; import { showToast, useGet, usePut } from '@brdp/engine'; import { ErrorAlert, FormGenerator } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import simaMessages from '../../../sima-messages'; const EditDetailForm = ({ code, principalIban, interestIban, mutateTable }: { code: string; principalIban: string | null; interestIban: string | null; mutateTable: () => void }) => { const messages = getFormatMessage(); const { data, mutate, isLoading, error } = usePut<UpdateIbanResponseType, UpdateIbanDataType>(Services.Sima.UPDATE_IBAN(code), { raw: true }); const handleOnFinish = async (values: EditDetailFormType) => { const newValues = { ibanTypeCode: values.shebaType, iban: values.newSheba }; mutate(newValues).then((data) => { if (data?.isSuccess) { hideAppModal('editDetailFormModal'); showToast({ title: messages(generalMessages.successful), description: data?.message || messages(generalMessages.hasSuccessResponse) }, 'success'); mutateTable(); } }); }; const { data: statusCategoryQueryData, isFetching: statusCategoryIsFetching } = useGet<CategoriesResponseType[]>(['sima-iban-type-category'], Services.Sima.GET_CATEGORIES('SIMA_IBAN_TYPE')); return ( <> {error && <ErrorAlert errorMessage={error.message || messages(generalMessages.errorBadHappened)} />} {data?.isSuccess === false && <ErrorAlert errorMessage={data?.message || messages(generalMessages.errorBadHappened)} />} <FormGenerator<EditDetailFormType> id={'editDetailForm'} isSubmitting={isLoading} submitLabel={messages(generalMessages.sendRequest)} onSubmit={handleOnFinish} reset resetLabel={messages(generalMessages.cancel)} onReset={() => hideAppModal('editDetailFormModal')} isLoading={statusCategoryIsFetching} initialValues={{ shababCode: code, profitSheba: interestIban !== null ? interestIban : '', principalSheba: principalIban !== null ? principalIban : '', shebaType: undefined, newSheba: '' }} fields={[{ name: 'shababCode', label: messages(generalMessages.shababCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'profitSheba', label: messages(simaMessages.profitSheba), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'principalSheba', label: messages(simaMessages.principalSheba), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'shebaType', label: messages(simaMessages.shebaType), type: 'select', options: { placeholder: messages(generalMessages.doChoose) }, loading: statusCategoryIsFetching, data: { static: statusCategoryQueryData?.resultData ? convertCategoryData(statusCategoryQueryData.resultData) : [] }, layout: { span: 2 } }, { name: 'newSheba', label: messages(simaMessages.newSheba), type: 'business', element: FormGenerator.IBANField, layout: { span: 2 }, options: { extraProps: { addIR: true } }, validation: { rules: [{ required: true, message: messages(generalMessages.requiredField) }, { validator: (_, value) => { const digitsOnly = value?.replace(/^IR/i, '').replace(/[^0-9]/g, '') || ''; if (digitsOnly.length < 24) return Promise.reject(new Error(messages(generalMessages.ibanValidation))); return Promise.resolve(); } }] } }]} /> </> ); }; export default EditDetailForm; export type EditDetailFormType = { shababCode: string; profitSheba: string; principalSheba: string; shebaType: string; newSheba: string }; export type UpdateIbanResponseType = string; export type UpdateIbanDataType = { ibanTypeCode: string; iban: string };",
    "sale-securities-table.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { GenerativeTable, useTablePagination } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { BusinessElementFieldsProps } from '@brdp/ui/form/form-field'; import type { SimaContractFormDTOInterestInfoListType } from './sale-securities.type'; const SaleSecuritiesTable: React.FC<BusinessElementFieldsProps<{ tableData: SimaContractFormDTOInterestInfoListType[] }>> = ({ ...props }) => { const { tableConfig, tableFromIndex } = useTablePagination(); const messages = getFormatMessage(); return ( <GenerativeTable rowKey='SaleSecuritiesTable' fromIndex={tableFromIndex} pagination={tableConfig(0)} data={props?.options?.extraProps?.tableData || []} columns={[{ key: 'interestReceptionDate', dataIndex: 'interestReceptionDate', title: messages(simaMessages.interestReceiptPeriods) }, { key: 'interestMatureAmount', dataIndex: 'interestMatureAmount', title: messages(simaMessages.dueInterestAmount, { title: `(${messages(generalMessages.rial)})` }) }, { key: 'interestPayAbleAmount', dataIndex: 'interestPayAbleAmount', title: messages(simaMessages.payableInterestAmount, { title: `(${messages(generalMessages.rial)})` }) }]} /> ); }; export default SaleSecuritiesTable;",
    "sale-form.tsx": "import CustomerSearch from '@/components/business-components/customerSearch/customer-search'; import { Services } from '@/services/url'; import { useGet } from '@brdp/engine'; import { ErrorAlert, Spin, Steps } from '@brdp/ui'; import FormGenerator, { useControlledForm } from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { useState } from 'react'; import simaMessages from '../../../../sima-messages'; import AmountConfirmation, { type AmountConfirmationPropType } from './amount-confirmation'; import SaleSecurities from './sale-securities'; import type { SaleDialogResponseType, SaleFormType } from './sale-securities.type'; import SignatureModal from './signature-modal'; const SaleForm = ({ code }: { code: string }) => { const messages = getFormatMessage(); const [current, setCurrent] = useState<number>(0); const [formData, setFormData] = useState<AmountConfirmationPropType>({ customerNumber: 0, depositNumber: '', totalAmount: 0, count: 0, securitiesCode: code }); const next = () => setCurrent((prev) => prev + 1); const prev = () => setCurrent((prev) => prev - 1); const { ControlledForm, setFieldsValue } = useControlledForm<SaleFormType>({ id: 'saleForm', confirmBeforeClose: true }); const { data: saleDialogData, isFetching: saleDialogFetching } = useGet<SaleDialogResponseType>(['sale-dialog', code], Services.Sima.GET_SALE_SECURITIES_DIALOG(code)); const handleFinish = (values: SaleFormType) => { const data = { customerNumber: values?.customerNumber, depositNumber: values?.depositNumber, totalAmount: values?.totalAmount, count: values?.count, securitiesCode: code }; setFormData(data); next(); }; const SellSecurities = () => { if (saleDialogFetching) return <Spin caption={messages(generalMessages.isFetchingData)} />; if (saleDialogData?.resultData) return ( <ControlledForm onSubmit={handleFinish} submitLabel={messages(generalMessages.continue)} isLoading={saleDialogFetching} initialValues={{ sellableAmount: saleDialogData.resultData?.saleAvailableBalance, resellableAmount: saleDialogData.resultData?.resalableSecuritiesCount, nominalValuePerSecurity: saleDialogData.resultData?.parValueFeature ?? '' }} fields={[{ name: 'sellableAmount', label: messages(simaMessages.sellableAmount), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'resellableAmount', label: messages(simaMessages.resellableAmount), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerNumber', label: messages(simaMessages.customerNumber), type: 'business', element: CustomerSearch, layout: { span: 2 }, dependencies: ['depositNumber'], validation: { rules: [{ required: true }] } }, { name: 'depositNumber', label: messages(simaMessages.depositNumber), type: 'input', layout: { span: 1 }, validation: { rules: [{ required: true }] } }, { name: 'count', label: messages(generalMessages.count), type: 'numeric', layout: { span: 1 }, validation: { rules: [{ pattern: /^[0-9]+$/, message: messages(generalMessages.onlyNumberValidField) }, { required: true }] } }, { name: 'nominalValuePerSecurity', label: messages(simaMessages.nominalValuePerSecurity), type: 'business', element: FormGenerator.AmountField, readOnly: true, layout: { span: 2 } }, { name: 'totalAmount', label: messages(generalMessages.totalAmount), type: 'business', element: FormGenerator.AmountField, layout: { span: 2 }, dependencies: ['nominalValuePerSecurity', 'count'], readOnly: true, disabled: ({ values }) => { const count = values?.count || 0; const parValueFeature = values?.nominalValuePerSecurity; setFieldsValue({ totalAmount: count * (parValueFeature ?? 0) }); return true; } }]} /> ); return <ErrorAlert errorMessage={saleDialogData?.message || messages(generalMessages.errorBadHappened)} />; }; const steps = [{ title: messages(simaMessages.sellSecurities), content: <SellSecurities /> }, { title: messages(simaMessages.amountConfirmation), content: ( <AmountConfirmation values={formData} prev={prev} next={next} setValues={setFormData} /> ) }, { title: messages(simaMessages.gateway), content: <SignatureModal prev={prev} next={next} formData={formData} /> }, { title: messages(simaMessages.submitSale), content: <SaleSecurities prev={prev} formData={formData} /> }]; return ( <> <Steps current={current} steps={steps} /> </> ); }; export default SaleForm;",
    "sale-securities.type.ts": "export type ValidateResponseType = { customerFullName: string; simaCustomerIdentifier: string; simaSecuritiesViewDTO: { id: number; code: string; name: string; status: { id: number; value: string; code: string }; principalIban: string; interestIban: string; groupCode: string; groupDescription: string; sellingStartDateFeature: string; sellingEndDateFeature: string; securitiesDuration: string; securitiesDurationUnit: string; interestPaymentIntervalFeature: number; interestPaymentIntervalUnitFeature: { id: number; value: string; code: string }; couponRate: number; redemptionRate: number; finalRateOfReturnFeature: number; redeemable: boolean; transferable: boolean; bondType: string; issueSubject: string; guarantor: string; trustee: string; obligor: string; issuer: string; countFeature: number; parValueFeature: number; totalRedemptedSecuritiesCount: number; totalSaledSecuritiesCount: number; totalResaledSecuritiesCount: number; totalSalableSecuritiesCount: number; interestAmount: number; dailyInterestAmount: number; couponsDate: string[]; isSpecial: boolean; debtorTopicId: number; creditorTopicId: number; debtorTopicCode: string; creditorTopicCode: string; depositNumber: string; lastSimaTaskItemLog: string; special: boolean }; simaContractDTOS: SimaContractDTOSType[]; simaContractFormDTO: { interestInfoList: SimaContractFormDTOInterestInfoListType[]; firstPeriodInterestAmount: string; totalInterestAmount: string }; count: number; depositNumber: string; customerNumber: number; currentDate: string; description: string; dueDate: string; selector: string }; export type SimaContractDTOSType = { id: number; simaCustomer: { rsCode: string; transactionCode: string; message: string; responseTimeMillis: number; requestId: string; requestDateTime: string; responseDateTime: string; resultUrl: string; correlationId: string; result: {}; abstractResponseType: { ack: 'SUCCESS'; correlationId: string; errors: [{ code: string; message: string; errorParams: string[] }]; any: [{}]; }; errorMessages: string[]; otherValues: { additionalProp1: string; additionalProp2: string; additionalProp3: string }; simaResponse: { id: number; version: number; active: boolean; manualId: string; enable: boolean; customerNumber: number; customerFullName: string; identifier: string; identifierType: { id: number; value: string; code: string }; dealerCode: null | string; shahabCode: null | string; gender: null | string; fatherName: null | string; birthDate: null | string; birthPlace: null | string; idNumber: null | string; idIssueDate: null | string; idIssuePlace: null | string; isReal: boolean; status: { id: number; value: string; code: string }; creationDateTime: string; modifiedDateTime: string } }; count: number; iban: string; description: string; transactionNumber: string; paidAmount: number; dueDate: string; status: { id: number; value: string; code: string }; redemptionInterestAmount: number; resaleInterestAmount: number; redemptionPenaltyAmount: number; contractForm: { id: number; data: string[] }; simaTransactionId: string; branchCode: string; reverseTransactionNumber: string }; export type SimaContractFormDTOInterestInfoListType = { interestReceptionDate: string; interestMatureAmount: string; interestPayAbleAmount: string; isCurrentPeriod: boolean }; export type SaleDialogResponseType = { securitiesCode: string; parValueFeature: number; sellingEndDateFeature: string; totalSaleInterestTillNow: number; saleAvailableBalance: number; resalableSecuritiesCount: number; totalSalePrincipal: null | number; totalSaleOrResaleAmount: null | number }; export type SaleFormType = { sellableAmount: number; resellableAmount: number; nominalValuePerSecurity: number; customerNumber: number; depositNumber: string; count: number; totalAmount: number; securitiesCode?: string }; export type SaleSecuritiesFormType = { customerInfo?: string; securitiesDetail?: string; line?: string; table?: string; customerName: string; customerId: string; date: string; securitiesCode: string; securitiesName: string; status: string; paymentSheba: string; profitPaymentSheba: string; securitiesGroupCode: string; securitiesGroupName: string; saleStartDate: string; saleEndDate: string; securitiesDuration: string; profitPaymentIntervals: string; redeemProfitRate: number; fixedProfitRate: number; couponRate: number; redeemable: boolean; transferable: boolean; securitiesType: string; publicationSubject: string; trusteeName: string; sponserName: string; guarantorName: string; publisherName: string; securitiesNominalValue: number; dailyProfitPerSecurity: number; requestedSecuritiesCount: number; description: string }; export type CompleteSalePropType = { customerFullName: string; simaCustomerIdentifier: string; simaSecuritiesViewDTO: { code: string }; count: number; depositNumber: string; customerNumber: number; currentDate: string; description: null | string; dueDate: string; selector: string };",
    "sale-securities.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, useGet, usePost } from '@brdp/engine'; import { ErrorAlert, Spin } from '@brdp/ui'; import FormGenerator from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import SaleSecuritiesTable from './sale-securities-table'; import type { SaleSecuritiesFormType, ValidateResponseType } from './sale-securities.type'; import { type ValidateSalePropType } from './signature-modal'; const SaleSecurities = ({ prev, formData }: { prev: () => void; formData: ValidateSalePropType }) => { const messages = getFormatMessage(); const { data: validateData, isFetching: validateFetching } = useGet<ValidateResponseType>(['validate-sale-securities'], Services.Sima.GET_VALIDATE_SALE_SECURITIES(formData)); const { data: completeData, isLoading: completeLoading, mutate: completeMutate, error: completeError } = usePost<string, ValidateResponseType>(Services.Sima.POST_SALE_SECURITIES_COMPLETE, { raw: true }); const handleFinish = () => { if (validateData?.resultData) { completeMutate(validateData.resultData).then((data) => { if (data?.isSuccess) { hideAppModal('saleSecuritiesModal'); showToast({ title: messages(generalMessages.successful), description: data?.resultData || messages(generalMessages.hasSuccessResponse) }, 'success'); } }); } }; if (validateFetching) return <Spin caption={messages(generalMessages.isFetchingData)} />; if (validateData?.resultData && validateData?.isSuccess) return ( <> {completeError && <ErrorAlert errorMessage={completeError?.message} />} {completeData?.isSuccess === false && <ErrorAlert errorMessage={completeData?.message || messages(generalMessages.errorBadHappened)} />} <FormGenerator<SaleSecuritiesFormType> id='saleSecuritiesForm' onSubmit={handleFinish} submitLabel={messages(generalMessages.submit)} isSubmitting={completeLoading} isLoading={validateFetching} onReset={() => prev()} reset resetLabel={messages(generalMessages.back)} initialValues={{ customerName: validateData.resultData?.customerFullName, customerId: validateData.resultData?.simaCustomerIdentifier, date: validateData.resultData?.currentDate, securitiesCode: validateData.resultData?.simaSecuritiesViewDTO?.code, securitiesName: validateData.resultData?.simaSecuritiesViewDTO?.name, status: validateData.resultData?.simaSecuritiesViewDTO?.status?.value, paymentSheba: validateData.resultData?.simaSecuritiesViewDTO?.principalIban, profitPaymentSheba: validateData.resultData?.simaSecuritiesViewDTO?.interestIban, securitiesGroupCode: validateData.resultData?.simaSecuritiesViewDTO?.groupCode, securitiesGroupName: validateData.resultData?.simaSecuritiesViewDTO?.groupDescription, saleStartDate: validateData.resultData?.simaSecuritiesViewDTO?.sellingStartDateFeature, saleEndDate: validateData.resultData?.simaSecuritiesViewDTO?.sellingEndDateFeature, securitiesDuration: validateData.resultData?.simaSecuritiesViewDTO?.securitiesDuration, profitPaymentIntervals: validateData.resultData?.simaSecuritiesViewDTO?.interestPaymentIntervalFeature ? `${validateData.resultData?.simaSecuritiesViewDTO?.interestPaymentIntervalFeature} ${validateData.resultData?.simaSecuritiesViewDTO?.interestPaymentIntervalUnitFeature?.value}` : undefined, redeemProfitRate: validateData.resultData?.simaSecuritiesViewDTO?.redemptionRate, fixedProfitRate: validateData.resultData?.simaSecuritiesViewDTO?.finalRateOfReturnFeature, couponRate: validateData.resultData?.simaSecuritiesViewDTO?.couponRate, redeemable: validateData.resultData?.simaSecuritiesViewDTO?.redeemable, transferable: validateData.resultData?.simaSecuritiesViewDTO?.transferable, securitiesType: validateData.resultData?.simaSecuritiesViewDTO?.isSpecial ? messages(generalMessages.private) : messages(generalMessages.public), publicationSubject: validateData.resultData?.simaSecuritiesViewDTO?.issueSubject, trusteeName: validateData.resultData?.simaSecuritiesViewDTO?.trustee, sponserName: validateData.resultData?.simaSecuritiesViewDTO?.obligor, guarantorName: validateData.resultData?.simaSecuritiesViewDTO?.guarantor, publisherName: validateData.resultData?.simaSecuritiesViewDTO?.issuer, securitiesNominalValue: validateData.resultData?.simaSecuritiesViewDTO?.parValueFeature, dailyProfitPerSecurity: validateData.resultData?.simaSecuritiesViewDTO?.dailyInterestAmount, requestedSecuritiesCount: formData.count, description: validateData.resultData?.description }} fields={[{ name: 'customerInfo', label: messages(simaMessages.customerDetailInfo), type: 'business', element: FormGenerator.CollapseField, layout: { span: 4 }, options: { extraProps: { fields: [{ name: 'customerName', label: messages(simaMessages.customerName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'customerId', label: messages(generalMessages.customerNumber), type: 'input', readOnly: true, layout: { span: 2 } }] } } }, { name: 'securitiesDetail', label: messages(simaMessages.securitiesDetail), type: 'business', element: FormGenerator.CollapseField, layout: { span: 4 }, options: { extraProps: { fields: [{ name: 'date', label: messages(generalMessages.date), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesCode', label: messages(generalMessages.shababCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesName', label: messages(simaMessages.securitiesName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'status', label: messages(simaMessages.securitiesStatus), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'paymentSheba', label: messages(simaMessages.paymentSheba), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'profitPaymentSheba', label: messages(simaMessages.profitPaymentSheba), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesGroupCode', label: messages(simaMessages.securitiesGroupCode), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesGroupName', label: messages(simaMessages.securitiesGroupName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'saleStartDate', label: messages(simaMessages.saleStartDate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'saleEndDate', label: messages(simaMessages.sellingEndDateTo), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesDuration', label: messages(simaMessages.securitiesDuration), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'profitPaymentIntervals', label: messages(simaMessages.profitPaymentIntervals), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'redeemProfitRate', label: messages(simaMessages.redeemProfitRate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'fixedProfitRate', label: messages(simaMessages.fixedProfitRate), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'couponRate', label: messages(simaMessages.couponRate), type: 'input', readOnly: true, layout: { span: 2 } }] } } }, { name: 'line', label: '', type: 'business', element: FormGenerator.CollapseField, layout: { span: 4 }, options: { extraProps: { fields: [{ name: 'redeemable', label: messages(simaMessages.redeemable), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'transferable', label: messages(simaMessages.transferable), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'securitiesType', label: messages(simaMessages.securitiesType), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'publicationSubject', label: messages(simaMessages.publicationSubject), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'trusteeName', label: messages(simaMessages.trusteeName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'sponserName', label: messages(simaMessages.sponserName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'guarantorName', label: messages(simaMessages.guarantorName), type: 'input', readOnly: true, layout: { span: 2 } }, { name: 'publisherName', label: messages(simaMessages.publisherName), type: 'input', readOnly: true, layout: { span: 2 } }] } } }, { name: 'table', label: '', layout: { span: 4 }, type: 'business', element: SaleSecuritiesTable, options: { extraProps: { tableData: validateData.resultData?.simaContractFormDTO?.interestInfoList } } }, { name: 'description', label: messages(generalMessages.description), type: 'textarea', layout: { span: 2 } }]} /> </> ); return <ErrorAlert errorMessage={validateData?.message || messages(generalMessages.errorBadHappened)} />; }; export default SaleSecurities;",
    "amount-confirmation.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { useGet } from '@brdp/engine'; import { ErrorAlert, Spin, WarningAlert } from '@brdp/ui'; import FormGenerator from '@brdp/ui/form'; import { generalMessages, getFormatMessage } from '@brdp/utils'; import { Dispatch, SetStateAction } from 'react'; const AmountConfirmation = ({ values, prev, next, setValues }: { values: AmountConfirmationPropType; prev: () => void; next: () => void; setValues: Dispatch<SetStateAction<AmountConfirmationPropType>> }) => { const messages = getFormatMessage(); const { data: amountData, isFetching: amountFetching } = useGet<AmountConfirmationResponseType>(['amount-confirmation'], Services.Sima.GET_AMOUNT_CONFIRMATION(values)); const handleFinish = () => { if (amountData?.resultData) { setValues({ ...values, totalAmount: amountData?.resultData?.totalSaleOrResaleAmount || values?.totalAmount }); } next(); }; if (amountFetching) return <Spin caption={messages(generalMessages.isFetchingData)} />; if (amountData?.resultData && amountData?.isSuccess) return ( <> {amountData?.resultData && ( <WarningAlert warningMessage={messages(simaMessages.amountConfirmationWarning, { totalSaleInterestTillNow: amountData?.resultData?.totalSaleInterestTillNow, totalSalePrincipal: String(amountData?.resultData?.totalSalePrincipal) })} /> )} <FormGenerator<{ amountConfirmation: number }> id='amountConfirmationForm' onSubmit={handleFinish} isLoading={amountFetching} reset resetLabel={messages(generalMessages.back)} onReset={() => prev()} submitLabel={messages(generalMessages.continue)} initialValues={{ amountConfirmation: amountData.resultData?.totalSaleOrResaleAmount || values?.totalAmount }} fields={[{ name: 'amountConfirmation', label: '', type: 'business', element: FormGenerator.AmountField, disabled: true, layout: { span: 4 } }]} /> </> ); return <ErrorAlert errorMessage={amountData?.message || messages(generalMessages.errorBadHappened)} />; }; export default AmountConfirmation; export type GetAmountPropType = { customerNumber: number; depositNumber: string; totalAmount: number; count: number; securitiesCode: string }; export type AmountConfirmationPropType = { customerNumber: number; depositNumber: string; totalAmount: number; count: number; securitiesCode: string }; export type AmountConfirmationResponseType = { securitiesCode: string; parValueFeature: number; sellingEndDateFeature: string; totalSaleInterestTillNow: number; saleAvailableBalance: number; resalableSecuritiesCount: number; totalSalePrincipal: null | number; totalSaleOrResaleAmount: null | number };",
    "block-customer-modal.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, useGet, usePost } from '@brdp/engine'; import { ErrorAlert, FormGenerator, Spin } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; type BlockStatusResponseType = { blocked: boolean }; type BlockCustomerFormType = { customerName: string; blockDescription: string }; type BlockCustomerModalProps = { customerNumber: number; customerName: string; identifier: string; identifierTypeCode: string; mutate: () => void }; type BlockCustomerDataType = { identifier: string; identifierTypeCode: string; blockDescription: string }; type BlockCustomerResponseType = { message: string }; const BlockCustomerModal = ({ customerNumber, customerName, identifier, identifierTypeCode, mutate }: BlockCustomerModalProps) => { const messages = getFormatMessage(); const { data: blockStatusData, isFetching: blockStatusIsFetching, error: blockStatusError } = useGet<BlockStatusResponseType>(['customer-block-status', identifier], Services.Sima.GET_CUSTOMER_BLOCK_STATUS({ identifier, identifierTypeCode }), { raw: true }); const { data: blockCustomerData, mutate: blockCustomerMutate, isLoading: blockCustomerIsLoading, error: blockCustomerError } = usePost<BlockCustomerResponseType, BlockCustomerDataType>(Services.Sima.POST_BLOCK_CUSTOMER(), { raw: true }); const handleBlockCustomer = (blockDescription: string) => { blockCustomerMutate({ identifier, identifierTypeCode, blockDescription }).then((result) => { if (result?.isSuccess) { showToast({ title: messages(generalMessages.successful), description: result?.resultData?.message || messages(simaMessages.customerBlockedSuccessfully) }, 'success'); mutate(); hideAppModal('blockCustomerModal'); } }); }; const unknownCustomerStatus = blockStatusData?.resultData?.blocked === undefined || blockStatusData?.resultData?.blocked === null; const isCustomerBlocked = blockStatusData?.resultData?.blocked === true; if (blockStatusIsFetching) return ( <Spin caption={messages(simaMessages.checkingLatestCustomerBlockStatus, { customerNumber })} /> ); if (blockStatusData?.isSuccess === false) return <ErrorAlert errorMessage={blockStatusData?.message || messages(generalMessages.errorBadHappened)} />; if (blockStatusError) return <ErrorAlert errorMessage={blockStatusError?.message || messages(generalMessages.errorBadHappened)} />; if (unknownCustomerStatus) return <ErrorAlert errorMessage={messages(simaMessages.unknownCustomerStatus)} />; if (isCustomerBlocked) return <ErrorAlert errorMessage={messages(simaMessages.customerIsBlocked)} />; return ( <> {blockCustomerError && <ErrorAlert errorMessage={blockCustomerError?.message || messages(generalMessages.errorBadHappened)} />} {blockCustomerData?.isSuccess === false && <ErrorAlert errorMessage={blockCustomerData?.message || messages(generalMessages.errorBadHappened)} />} <FormGenerator<BlockCustomerFormType> id='blockCustomerForm' isSubmitting={blockCustomerIsLoading} submitLabel={messages(generalMessages.confirm)} onSubmit={(values) => handleBlockCustomer(values.blockDescription)} reset resetLabel={messages(generalMessages.cancel)} onReset={() => { hideAppModal('blockCustomerModal'); mutate(); }} initialValues={{ customerName }} fields={[{ name: 'customerName', type: 'input', label: messages(generalMessages.customerName), layout: { span: 4 }, disabled: true }, { name: 'blockDescription', type: 'textarea', label: messages(generalMessages.description), layout: { span: 4 } }]} /> </> ); }; export default BlockCustomerModal;",
    "check-block-status-modal.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { useGet } from '@brdp/engine'; import { ErrorAlert, Spin, SuccessAlert } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; type BlockStatusResponseType = { blocked: boolean }; type CheckBlockStatusModalProps = { customerNumber: number; identifier: string; identifierTypeCode: string }; const CheckBlockStatusModal = ({ customerNumber, identifier, identifierTypeCode }: CheckBlockStatusModalProps) => { const messages = getFormatMessage(); const { data, isFetching, error } = useGet<BlockStatusResponseType>(['customer-block-status', identifier], Services.Sima.GET_CUSTOMER_BLOCK_STATUS({ identifier, identifierTypeCode }), { raw: true }); if (isFetching) return <Spin caption={messages(simaMessages.checkingCustomerBlockStatus, { customerNumber })} />; return ( <> {data?.isSuccess === true && <SuccessAlert successMessage={messages(simaMessages.customerStatusUpdatedSuccessfully)} />} {(data?.isSuccess === false || error) && <ErrorAlert errorMessage={data?.message || error?.message || messages(generalMessages.errorBadHappened)} />} </> ); }; export default CheckBlockStatusModal;",
    "unblock-customer-modal.tsx": "import simaMessages from '@/pages/dashboard/sima-messages'; import { Services } from '@/services/url'; import { hideAppModal } from '@/utils/hooks/useAppModal'; import { showToast, useGet, usePost } from '@brdp/engine'; import { ErrorAlert, FormGenerator, Spin } from '@brdp/ui'; import { generalMessages, getFormatMessage } from '@brdp/utils'; type BlockStatusResponseType = { blocked: boolean }; type UnblockCustomerFormType = { customerName: string; blockDescription: string }; type UnblockCustomerModalProps = { customerNumber: number; customerName: string; identifier: string; identifierTypeCode: string; mutate: () => void }; type UnblockCustomerDataType = { identifier: string; identifierTypeCode: string; blockDescription: string }; type UnblockCustomerResponseType = { message: string }; const UnblockCustomerModal = ({ customerNumber, customerName, identifier, identifierTypeCode, mutate }: UnblockCustomerModalProps) => { const messages = getFormatMessage(); const { data: blockStatusData, isFetching: blockStatusIsFetching, error: blockStatusError } = useGet<BlockStatusResponseType>(['customer-block-status', identifier], Services.Sima.GET_CUSTOMER_BLOCK_STATUS({ identifier, identifierTypeCode }), { raw: true }); const { data: unblockCustomerData, mutate: unblockCustomerMutate, isLoading: unblockCustomerIsLoading, error: unblockCustomerError } = usePost<UnblockCustomerResponseType, UnblockCustomerDataType>(Services.Sima.POST_UNBLOCK_CUSTOMER(), { raw: true }); const handleUnblockCustomer = (blockDescription: string) => { unblockCustomerMutate({ identifier, identifierTypeCode, blockDescription }).then((result) => { if (result?.isSuccess) { showToast({ title: messages(generalMessages.successful), description: result?.resultData?.message || messages(simaMessages.customerUnblockedSuccessfully) }, 'success'); mutate(); hideAppModal('unblockCustomerModal'); } }); }; const unknownCustomerStatus = blockStatusData?.resultData?.blocked === undefined || blockStatusData?.resultData?.blocked === null; const isCustomerActive = blockStatusData?.resultData?.blocked === false; if (blockStatusIsFetching) return <Spin caption={messages(simaMessages.checkingLatestCustomerBlockStatus, { customerNumber })} />; if (blockStatusData?.isSuccess === false) return <ErrorAlert errorMessage={blockStatusData?.message || messages(generalMessages.errorBadHappened)} />; if (blockStatusError) return <ErrorAlert errorMessage={blockStatusError?.message || messages(generalMessages.errorBadHappened)} />; if (unknownCustomerStatus) return <ErrorAlert errorMessage={messages(simaMessages.unknownCustomerStatus)} />; if (isCustomerActive) return <ErrorAlert errorMessage={messages(simaMessages.customerIsActive)} />; return ( <> {unblockCustomerError && <ErrorAlert errorMessage={unblockCustomerError?.message || messages(generalMessages.errorBadHappened)} />} {unblockCustomerData?.isSuccess === false && <ErrorAlert errorMessage={unblockCustomerData?.message || messages(generalMessages.errorBadHappened)} />} <FormGenerator<UnblockCustomerFormType> id='unblockCustomerForm' isSubmitting={unblockCustomerIsLoading} submitLabel={messages(generalMessages.confirm)} onSubmit={(values) => handleUnblockCustomer(values.blockDescription)} reset resetLabel={messages(generalMessages.cancel)} onReset={() => { hideAppModal('unblockCustomerModal'); mutate(); }} initialValues={{ customerName }} fields={[{ name: 'customerName', type: 'input', label: messages(generalMessages.customerName), layout: { span: 4 }, disabled: true }, { name: 'blockDescription', type: 'textarea', label: messages(generalMessages.description), layout: { span: 4 } }]} /> </> ); }; export default UnblockCustomerModal;"
  }
}
